<!DOCTYPE html>
<html lang="en">
<!--
    Demo Version - Markdown WYSIWYG Editor
    
    This is a demo version for GitHub Pages hosting.
    - No autosave functionality
    - No localStorage/cookies
    - Same rendering as Production2
    - Download full version for local use with autosave
-->
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Markdown WYSIWYG Editor â€” Demo</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --bg-light: #fefefe;
            --fg-light: #222;
            --bg-dark: #1e1e1e;
            --fg-dark: #ddd;
        }

        body.light {
            background: var(--bg-light);
            color: var(--fg-light);
        }

        body.dark {
            background: var(--bg-dark);
            color: var(--fg-dark);
        }

        html,
        body {
            height: 100vh;
            margin: 0;
            padding: 0;
            font-family: 'Roboto Mono', monospace;
            display: flex;
            flex-direction: column;
        }

        .toolbar {
            background: #eee;
            border-bottom: 1px solid #ccc;
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .formatting-buttons {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .utility-buttons {
            display: flex;
            gap: 8px;
            align-items: center;
        }  
      .separator {
            width: 1px;
            height: 24px;
            background: #ccc;
            margin: 0 8px;
        }

        body.dark .separator {
            background: #555;
        }

        button {
            border: 1px solid #bbb;
            background: #fff;
            border-radius: 6px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 14px;
        }

        .format-btn {
            padding: 4px 8px;
            font-size: 12px;
            min-width: 32px;
            transition: all 0.2s ease;
        }

        .format-btn:hover {
            background: #f0f0f0;
        }

        .format-btn.active {
            background: #007acc;
            color: #fff;
            border-color: #007acc;
        }

        body.dark .toolbar {
            background: #2a2a2a;
            border-bottom-color: #444;
        }

        body.dark button {
            background: #333;
            color: #ddd;
            border-color: #555;
        }

        body.dark .format-btn:hover {
            background: #444;
        }

        body.dark .format-btn.active {
            background: #007acc;
            color: #fff;
        }

        .editor-wrapper {
            display: flex;
            flex: 1;
            height: calc(100vh - 80px);
            /* toolbar + status bar height */
            overflow: hidden;
        }       
 .line-numbers {
            width: auto;
            min-width: 50px;
            padding: 16px 8px 16px 8px;
            text-align: right;
            user-select: none;
            background: #f0f0f0;
            color: #777;
            overflow: hidden;
            box-sizing: border-box;
            font-size: 16px;
            line-height: 1.4;
            font-family: 'Roboto Mono', monospace;
            position: relative;
        }

        .line-numbers .line-number {
            position: absolute;
            left: 8px;
            right: 8px;
            text-align: right;
            line-height: 1.4;
        }

        body.dark .line-numbers {
            background: #262626;
            color: #666;
        }

        #editor {
            flex: 1;
            padding: 16px;
            border: none;
            outline: none;
            resize: none;
            font-family: 'Roboto Mono', monospace;
            font-size: 16px;
            line-height: 1.4;
            box-sizing: border-box;
            overflow: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            background: transparent;
            color: inherit;
            min-height: 100%;
        }

        #editor:empty:before {
            content: attr(data-placeholder);
            color: #999;
            pointer-events: none;
        }

        body.dark #editor:empty:before {
            color: #666;
        }       
 /* Markdown formatting styles */
        #editor h1,
        #editor h2,
        #editor h3 {
            margin: 0.5em 0;
            font-weight: bold;
            line-height: 1.2;
        }

        #editor h1 {
            font-size: 2em;
        }

        #editor h2 {
            font-size: 1.5em;
        }

        #editor h3 {
            font-size: 1.2em;
        }

        #editor strong {
            font-weight: bold;
        }

        #editor em {
            font-style: italic;
        }

        #editor del {
            text-decoration: line-through;
        }

        #editor mark {
            background-color: #ffeb3b;
            color: #000;
            padding: 0 2px;
        }

        body.dark #editor mark {
            background-color: #ffc107;
            color: #000;
        }

        #editor hr {
            border: none;
            border-top: 2px solid #ccc;
            margin: 1em 0;
            width: 100%;
        }

        body.dark #editor hr {
            border-top-color: #555;
        }

        /* Editor line styles */
        .editor-line {
            min-height: 1.4em;
            line-height: 1.4;
            position: relative;
        }   
     .editor-line.editing {
            /* Raw markdown editing mode */
            font-family: 'Roboto Mono', monospace;
        }

        .editor-line:not(.editing) {
            /* Formatted display mode */
            font-family: inherit;
        }

        /* Collapsible heading styles */
        .editor-line.heading {
            position: relative;
        }

        .collapse-arrow {
            display: inline-block;
            margin-right: 8px;
            width: 0;
            height: 0;
            border-left: 10px solid #666;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            cursor: pointer;
            transition: transform 0.2s ease;
            vertical-align: middle;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            pointer-events: auto;
        }

        .collapse-arrow.collapsed {
            transform: rotate(-90deg);
        }

        body.dark .collapse-arrow {
            border-left-color: #aaa;
        }

        .editor-line.collapsed {
            display: none;
        }

        .editor-line.heading.has-collapsed-content {
            margin-bottom: 0.2em;
            border-left: 3px solid #007acc;
            padding-left: 8px;
            background-color: rgba(0, 122, 204, 0.05);
        }

        body.dark .editor-line.heading.has-collapsed-content {
            border-left-color: #4fc3f7;
            background-color: rgba(79, 195, 247, 0.05);
        } 
       /* Adjust line numbers for collapse arrows */
        .line-numbers {
            width: auto;
            min-width: 50px;
            /* Auto width to fit content */
            padding: 16px 12px 16px 8px;
            /* Reduced right padding */
        }

        .main-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .statusbar {
            background: #eee;
            border-top: 1px solid #ccc;
            padding: 6px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            flex-shrink: 0;
        }

        body.dark .statusbar {
            background: #2a2a2a;
            border-top-color: #444;
        }

        /* Hidden mirror to measure wrapped lines */
        #mirror {
            position: absolute;
            visibility: hidden;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
            top: -9999px;
            left: -9999px;
            box-sizing: border-box;
        }

        /* Feedback Link Hover Effect */
        #feedbackLink:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
        }

        #feedbackLink:active {
            transform: translateY(0);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
    </style>
</head>

<body class="light">
    <div class="main-container">
        <div class="toolbar">
            <div class="formatting-buttons">
                <button id="boldBtn" class="format-btn" title="Bold (Ctrl+B)"><strong>B</strong></button>
                <button id="italicBtn" class="format-btn" title="Italic (Ctrl+I)"><em>I</em></button>
                <button id="strikeBtn" class="format-btn" title="Strikethrough">SÌ¶</button>
                <button id="highlightBtn" class="format-btn" title="Highlight">H</button>
                <div class="separator"></div>
                <button id="h1Btn" class="format-btn" title="Heading 1">H1</button>
                <button id="h2Btn" class="format-btn" title="Heading 2">H2</button>
                <button id="h3Btn" class="format-btn" title="Heading 3">H3</button>
                <div class="separator"></div>
                <button id="ulBtn" class="format-btn" title="Unordered List">â€¢ List</button>
                <button id="olBtn" class="format-btn" title="Ordered List">1. List</button>
                <button id="hrBtn" class="format-btn" title="Horizontal Rule">â€”</button>
            </div>
            <div class="utility-buttons">
                <button id="copyAllBtn" title="Copy all text to clipboard (Ctrl+Shift+C)">Copy All ðŸ“‹</button>
                <button id="themeBtn">Toggle Theme</button>
                <button id="saveBtn">Save ðŸ’¾</button>
            </div>
        </div> 
       <div class="editor-wrapper">
            <div id="lineNumbers" class="line-numbers" aria-hidden="true"></div>
            <div id="editor" contenteditable="true" placeholder="Start typing..." spellcheck="false"
                data-placeholder="Start typing..."></div>
        </div>

        <div class="statusbar">
            <span id="status">Words: 0 | Characters: 0 | Lines: 0</span>
            <span id="demo-notice" style="color: #666; font-size: 12px;">Demo Mode - Download full version for autosave</span>
        </div>
    </div>
    
    <!-- Feedback Link Button -->
    <a href="https://forms.gle/85brLpJVBruTfKtw7" target="_blank" id="feedbackLink" style="
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 12px 24px;
        border-radius: 8px;
        text-decoration: none;
        font-family: 'Roboto Mono', monospace;
        font-size: 14px;
        font-weight: 600;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        transition: all 0.3s ease;
        z-index: 1000;
        cursor: pointer;
    ">
        ðŸ’­ Feedback & Bug Reports
    </a>
</body>

<!-- Mirror element removed - using smart auto-measuring line numbers instead -->

<script>
    (() => {
        const STORAGE_KEY = "marktext_autosave";

        // MarkdownRenderer class for parsing and rendering markdown
        class MarkdownRenderer {
            constructor() {
                this.patterns = {
                    bold: /\*\*(.*?)\*\*/g,
                    italic: /\*(.*?)\*/g,
                    strikethrough: /~~(.*?)~~/g,
                    highlight: /==(.*?)==/g,
                    heading1: /^# (.+)$/,
                    heading2: /^## (.+)$/,
                    heading3: /^### (.+)$/,
                    unorderedList: /^(\s*)[-*+] (.+)$/,
                    orderedList: /^(\s*)(\d+)\. (.+)$/,
                    horizontalRule: /^(---|\*\*\*|___)$/
                };
            }

            // NEW: Parse inline markdown with proper nesting support
            parseInlineFormatting(text) {
                let html = this.escapeHtml(text);
                
                // Process bold first (** before *) to handle nested formatting correctly
                // This ensures **text** is processed before *text*
                html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
                
                // Then process italic, but avoid matching already processed bold markers
                // Use negative lookbehind/lookahead to avoid matching * that's part of **
                html = html.replace(/(?<!\*)\*(?!\*)(.+?)(?<!\*)\*(?!\*)/g, '<em>$1</em>');
                
                // Process other formatting
                html = html.replace(/~~(.+?)~~/g, '<del>$1</del>');
                html = html.replace(/==(.+?)==/g, '<mark>$1</mark>');
                
                return html;
            }

            // Convert markdown text to HTML elements with performance optimization
            parseMarkdown(text) {
                if (!text) return document.createTextNode('');

                // Use DocumentFragment for efficient DOM manipulation
                const fragment = document.createDocumentFragment();
                const lines = text.split('\n');

                // Batch DOM operations for better performance
                const elements = [];
                lines.forEach((line, index) => {
                    const lineElement = this.parseLine(line);
                    elements.push(lineElement);

                    // Add line break except for last line
                    if (index < lines.length - 1) {
                        elements.push(document.createElement('br'));
                    }
                });

                // Append all elements at once
                elements.forEach(el => fragment.appendChild(el));

                return fragment;
            }     
       // Parse a single line of markdown
            parseLine(line) {
                if (!line.trim()) {
                    const div = document.createElement('div');
                    div.style.display = 'inline';
                    div.appendChild(document.createTextNode('\u00A0')); // Non-breaking space for empty lines
                    return div;
                }

                // Check for headings first
                if (this.patterns.heading1.test(line)) {
                    const h1 = document.createElement('h1');
                    const match = line.match(this.patterns.heading1);
                    h1.textContent = match[1];
                    return h1;
                }

                if (this.patterns.heading2.test(line)) {
                    const h2 = document.createElement('h2');
                    const match = line.match(this.patterns.heading2);
                    h2.textContent = match[1];
                    return h2;
                }

                if (this.patterns.heading3.test(line)) {
                    const h3 = document.createElement('h3');
                    const match = line.match(this.patterns.heading3);
                    h3.textContent = match[1];
                    return h3;
                }

                // Check for unordered list
                if (this.patterns.unorderedList.test(line)) {
                    const li = document.createElement('li');
                    const match = line.match(this.patterns.unorderedList);
                    const indent = match[1].length;

                    // Process the list content for inline formatting (bold, italic, etc.)
                    const content = match[2];
                    const html = this.parseInlineFormatting(content);

                    li.innerHTML = html;
                    li.style.marginLeft = `${indent * 20 + 10}px`; // Add 10px to move bullets right
                    li.style.listStyleType = 'disc';
                    li.style.display = 'list-item';
                    return li;
                }     
           // Check for ordered list
                if (this.patterns.orderedList.test(line)) {
                    const div = document.createElement('div');
                    const match = line.match(this.patterns.orderedList);
                    const indent = match[1].length;
                    const number = match[2];
                    const content = match[3];

                    // Create a div that looks like a numbered list item
                    div.style.display = 'flex';
                    div.style.marginLeft = `${indent * 20}px`;

                    // Create number span
                    const numberSpan = document.createElement('span');
                    numberSpan.textContent = number + '. ';
                    numberSpan.style.minWidth = '2em';
                    numberSpan.style.fontWeight = 'normal';

                    // Create content span with inline formatting support
                    const contentSpan = document.createElement('span');

                    // Process the list content for inline formatting (bold, italic, etc.)
                    const html = this.parseInlineFormatting(content);

                    contentSpan.innerHTML = html;

                    div.appendChild(numberSpan);
                    div.appendChild(contentSpan);
                    return div;
                }

                // Check for horizontal rule
                if (this.patterns.horizontalRule.test(line)) {
                    const hr = document.createElement('hr');
                    return hr;
                }

                // Regular line with inline formatting
                const div = document.createElement('div');
                div.style.display = 'inline';

                const html = this.parseInlineFormatting(line);

                div.innerHTML = html;
                return div;
            }   
         // Extract markdown from formatted DOM with error handling
            extractMarkdown(element) {
                if (!element) return '';

                try {
                    // Handle single line elements
                    if (element.classList && element.classList.contains('editor-line')) {
                        if (element.classList.contains('editing')) {
                            return element.textContent || '';
                        }
                        return this.extractLineMarkdown(element);
                    }

                    // Handle full editor content
                    const lines = element.querySelectorAll('.editor-line');
                    if (lines.length > 0) {
                        const content = [];
                        lines.forEach(line => {
                            if (line.classList.contains('editing')) {
                                content.push(line.textContent || '');
                            } else {
                                content.push(this.extractLineMarkdown(line));
                            }
                        });
                        return content.join('\n');
                    }

                    // Fallback to text content
                    return element.textContent || '';
                } catch (error) {
                    return element.textContent || '';
                }
            }

            // Extract markdown from a single line element
            extractLineMarkdown(lineElement) {
                const firstChild = lineElement.firstChild;
                if (!firstChild) return '';

                // Handle different element types
                switch (firstChild.tagName?.toLowerCase()) {
                    case 'h1':
                        return '# ' + firstChild.textContent;
                    case 'h2':
                        return '## ' + firstChild.textContent;
                    case 'h3':
                        return '### ' + firstChild.textContent;
                    case 'li':
                        const indent = parseInt(firstChild.style.marginLeft) / 20 || 0;
                        const indentStr = ' '.repeat(indent);
                        // Extract inline markdown from the list item content
                        const listContent = this.extractInlineMarkdown(firstChild);
                        if (firstChild.style.listStyleType === 'decimal') {
                            return indentStr + '1. ' + listContent;
                        } else {
                            return indentStr + '- ' + listContent;
                        }
                    case 'div':
                        // Check if this is an ordered list div (has flex display and number span)
                        if (firstChild.style.display === 'flex' && firstChild.children.length === 2) {
                            const numberSpan = firstChild.children[0];
                            const contentSpan = firstChild.children[1];
                            if (numberSpan && contentSpan) {
                                const indent = parseInt(firstChild.style.marginLeft) / 20 || 0;
                                const indentStr = ' '.repeat(indent);
                                // Extract inline markdown from the content span
                                const listContent = this.extractInlineMarkdown(contentSpan);
                                return indentStr + numberSpan.textContent + listContent;
                            }
                        }
                        // Fall through to default for regular divs
                        return this.extractInlineMarkdown(lineElement);
                    case 'hr':
                        return '---';
                    default:
                        // Handle inline formatting
                        return this.extractInlineMarkdown(lineElement);
                }
            } 
           // FIX: Enhanced extractInlineMarkdown to properly convert <strong> back to **text** with nested support
            extractInlineMarkdown(element) {
                let markdown = '';

                for (let node of element.childNodes) {
                    if (node.nodeType === Node.TEXT_NODE) {
                        markdown += node.textContent;
                    } else if (node.nodeType === Node.ELEMENT_NODE) {
                        switch (node.tagName.toLowerCase()) {
                            case 'strong':
                                // Recursively extract nested content to handle nested formatting
                                markdown += '**' + this.extractInlineMarkdown(node) + '**';
                                break;
                            case 'em':
                                // Recursively extract nested content to handle nested formatting
                                markdown += '*' + this.extractInlineMarkdown(node) + '*';
                                break;
                            case 'del':
                                markdown += '~~' + this.extractInlineMarkdown(node) + '~~';
                                break;
                            case 'mark':
                                markdown += '==' + this.extractInlineMarkdown(node) + '==';
                                break;
                            case 'br':
                                markdown += '\n';
                                break;
                            default:
                                // For unknown elements, recursively extract their content
                                markdown += this.extractInlineMarkdown(node);
                        }
                    }
                }

                return markdown;
            }

            // Check if element is being actively edited
            isActivelyEditing(element) {
                const selection = window.getSelection();
                if (!selection.rangeCount) return false;

                const range = selection.getRangeAt(0);
                return element.contains(range.commonAncestorContainer);
            }

            // Escape HTML characters
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        }     
   // EditingController class for managing line-based editing (Obsidian-style)
        class EditingController {
            constructor(editor, renderer) {
                this.editor = editor;
                this.renderer = renderer;
                this.currentEditingLineElement = null;
                this.isInitialized = false;
                this.lineNumberUpdateTimeout = null;
                this.lastLineNumberUpdate = 0;
                this.isRapidOperation = false;
                this.rapidOperationTimeout = null;

                // Undo/Redo system
                this.history = [];
                this.historyIndex = -1;
                this.maxHistorySize = 50;
                this.lastSavedState = '';
                this.lastWordCount = 0; // FIX: Track word count for improved undo system
                this.delayedFormatTimeout = null; // FIX: Track delayed formatting timeout

                this.setupEventListeners();
            }

            setupEventListeners() {
                // Handle input events for real-time updates
                this.editor.addEventListener('input', (e) => {
                    this.handleInput(e);
                    this.ensureMinimumStructure();
                    this.ensureCursorVisible();

                    // Smart line number update with debouncing
                    this.scheduleLineNumberUpdate();
                });

                // Smart line number system: observe DOM changes for auto-measuring
                // Only watch for structural changes, not text content changes
                const observer = new MutationObserver((mutations) => {
                    let shouldUpdate = false;

                    for (const mutation of mutations) {
                        // Only update for structural changes (adding/removing lines)
                        if (mutation.type === 'childList' &&
                            (mutation.addedNodes.length > 0 || mutation.removedNodes.length > 0)) {
                            // Check if editor-line elements were added/removed
                            const hasLineChanges = Array.from(mutation.addedNodes).some(node =>
                                node.nodeType === Node.ELEMENT_NODE && node.classList?.contains('editor-line')
                            ) || Array.from(mutation.removedNodes).some(node =>
                                node.nodeType === Node.ELEMENT_NODE && node.classList?.contains('editor-line')
                            );

                            if (hasLineChanges) {
                                shouldUpdate = true;
                                break;
                            }
                        }
                    }

                    if (shouldUpdate) {
                        this.scheduleLineNumberUpdate();
                    }
                });
                observer.observe(this.editor, {
                    childList: true,
                    subtree: false // Only watch direct children, not deep changes
                });    
            // Handle selection changes to switch editing lines
                document.addEventListener('selectionchange', () => {
                    this.handleSelectionChange();
                });

                // Handle keydown events (merged for efficiency)
                this.editor.addEventListener('keydown', (e) => {
                    // Intercept Ctrl+A + Delete/Backspace combinations
                    if ((e.key === 'Delete' || e.key === 'Backspace') && this.isSelectAllActive()) {
                        e.preventDefault();
                        this.handleSelectAllDelete();
                        return;
                    }

                    // Handle specific keys
                    if (e.key === 'Enter') {
                        this.handleEnterKey(e);
                    } else if (e.key === 'Tab') {
                        this.handleTabKey(e);
                    } else if (e.key === 'Backspace') {
                        this.handleBackspaceKey(e);
                        // Smart line number update after deletion
                        setTimeout(() => this.scheduleLineNumberUpdate(), 50);
                    } else if (e.key === 'Delete') {
                        this.handleDeleteKey(e);
                        // Smart line number update after deletion
                        setTimeout(() => this.scheduleLineNumberUpdate(), 50);
                    } else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                        // Handle arrow keys to prevent cursor jumping
                        setTimeout(() => this.handleSelectionChange(), 0);
                    }
                });

                // Handle blur to format all lines
                this.editor.addEventListener('blur', () => {
                    this.formatAllLines();
                });

                // Handle focus to start editing
                this.editor.addEventListener('focus', () => {
                    if (!this.isInitialized) {
                        this.initializeEditor();
                    }
                    setTimeout(() => this.handleSelectionChange(), 0);
                });

                // Handle click events to switch lines
                this.editor.addEventListener('click', (e) => {
                    // Don't handle selection change if clicking on collapse arrow or its parent
                    if (e.target.classList.contains('collapse-arrow') ||
                        e.target.closest('.collapse-arrow')) {
                        return;
                    }
                    setTimeout(() => this.handleSelectionChange(), 0);
                });

                // Handle paste events to maintain structure
                this.editor.addEventListener('paste', (e) => {
                    e.preventDefault();

                    // Get pasted text
                    const pastedText = (e.clipboardData || window.clipboardData).getData('text');

                    if (pastedText) {
                        // FIX: Insert pasted content at cursor position instead of replacing everything
                        this.insertPastedContentAtCursor(pastedText);
                    }
                });
            }    
        // Clean pasted content to prevent extra lines
            cleanPastedContent(content) {
                if (!content) return '';

                // Remove excessive newlines (more than 2 consecutive)
                let cleaned = content.replace(/\n{3,}/g, '\n\n');

                // Remove trailing whitespace from lines
                cleaned = cleaned.split('\n').map(line => line.trimEnd()).join('\n');

                // Remove leading/trailing empty lines
                cleaned = cleaned.trim();

                return cleaned;
            }

            // FIX: Insert pasted content at cursor position instead of replacing everything
            insertPastedContentAtCursor(pastedText) {
                const currentLine = this.getCurrentLineElement();
                if (!currentLine) return;

                // Clean the pasted content
                const cleanedContent = this.cleanPastedContent(pastedText);
                if (!cleanedContent) return;

                // Ensure current line is in edit mode
                if (!currentLine.classList.contains('editing')) {
                    this.makeLineEditable(currentLine);
                }

                // Get current cursor position
                const selection = window.getSelection();
                if (!selection.rangeCount) return;

                const range = selection.getRangeAt(0);
                
                // Split pasted content into lines
                const pastedLines = cleanedContent.split('\n');
                
                if (pastedLines.length === 1) {
                    // Single line paste - just insert at cursor
                    const textNode = document.createTextNode(pastedLines[0]);
                    range.deleteContents();
                    range.insertNode(textNode);
                    
                    // Position cursor after inserted text
                    range.setStartAfter(textNode);
                    range.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(range);
                } else {
                    // Multi-line paste - more complex handling
                    this.handleMultiLinePaste(currentLine, pastedLines, range);
                }

                // Update line numbers and trigger autosave
                setTimeout(() => {
                    this.updateLineNumbers();
                    if (this.autosaveManager) {
                        this.autosaveManager.scheduleSave();
                    }
                }, 50);
            }

            // Handle multi-line paste by splitting current line and inserting new lines
            handleMultiLinePaste(currentLine, pastedLines, range) {
                // Get text before and after cursor
                const lineText = currentLine.textContent || '';
                const cursorPos = this.getCursorPositionInLine(currentLine);
                const textBefore = lineText.substring(0, cursorPos);
                const textAfter = lineText.substring(cursorPos);

                // Update current line with first part + first pasted line
                currentLine.textContent = textBefore + pastedLines[0];

                let lastInsertedLine = currentLine;

                // Insert middle lines (if any)
                for (let i = 1; i < pastedLines.length - 1; i++) {
                    const newLine = document.createElement('div');
                    newLine.className = 'editor-line editing';
                    newLine.textContent = pastedLines[i];
                    
                    lastInsertedLine.parentNode.insertBefore(newLine, lastInsertedLine.nextSibling);
                    lastInsertedLine = newLine;
                }

                // Insert final line with remaining text
                if (pastedLines.length > 1) {
                    const finalLine = document.createElement('div');
                    finalLine.className = 'editor-line editing';
                    finalLine.textContent = pastedLines[pastedLines.length - 1] + textAfter;
                    
                    lastInsertedLine.parentNode.insertBefore(finalLine, lastInsertedLine.nextSibling);
                    
                    // Position cursor at end of pasted content in final line
                    const cursorPosition = pastedLines[pastedLines.length - 1].length;
                    setTimeout(() => {
                        this.setCursorInLineSafe(finalLine, cursorPosition);
                        this.currentEditingLineElement = finalLine;
                    }, 10);
                }

                // Update line indices
                this.updateLineIndices();
            }

            // Handle pasted content by converting it to proper line structure (LEGACY - kept for compatibility)
            handlePastedContent(pastedText) {
                // Clean the pasted content first
                const cleanedContent = this.cleanPastedContent(pastedText);

                // Clear editor completely
                this.editor.innerHTML = '';

                // Reset initialization state
                this.isInitialized = false;
                this.currentEditingLineElement = null;

                // Directly render the formatted content
                this.renderFormattedContent(cleanedContent);

                // Mark as initialized
                this.isInitialized = true;

                // Update line numbers (self-contained, no double rendering)
                const updateLineNumbers = () => {
                    this.updateLineNumbersNow();
                };

                // Immediate update
                updateLineNumbers();

                // Delayed updates to ensure everything is ready
                setTimeout(updateLineNumbers, 50);
                setTimeout(updateLineNumbers, 150);
                setTimeout(updateLineNumbers, 300);

                setTimeout(() => {
                    // Trigger autosave after paste (treat as edit operation)
                    if (this.autosaveManager) {
                        this.autosaveManager.scheduleSave();
                    }

                    // Trigger input event to ensure all handlers are called
                    const inputEvent = new Event('input', { bubbles: true });
                    this.editor.dispatchEvent(inputEvent);
                }, 100);
            }     
       // Reinitialize editor with new content
            reinitializeWithContent(content) {
                this.isInitialized = false;
                this.editor.innerHTML = '';
                this.editor.textContent = content;

                setTimeout(() => {
                    this.initializeEditor();
                    this.updateLineNumbers();
                }, 0);
            }

            // Initialize editor with formatted content
            initializeEditor() {
                if (this.isInitialized) return;

                const content = this.editor.textContent || '';

                try {
                    if (content.trim()) {
                        this.renderFormattedContent(content);

                        // Force immediate formatting of all lines after rendering
                        setTimeout(() => {
                            const lines = this.editor.querySelectorAll('.editor-line');
                            lines.forEach(line => {
                                if (!line.classList.contains('editing')) {
                                    // Line should be formatted, ensure it's properly rendered
                                    const rawContent = this.getLineRawContent(line);
                                    if (rawContent.trim()) {
                                        const formattedElement = this.renderer.parseLine(rawContent);
                                        line.innerHTML = '';
                                        if (formattedElement.tagName === 'DIV') {
                                            line.innerHTML = formattedElement.innerHTML;
                                        } else {
                                            line.appendChild(formattedElement);
                                        }
                                    }
                                }
                            });
                            this.scheduleLineNumberUpdate();
                        }, 50);
                    } else {
                        // Clear everything first
                        this.editor.innerHTML = '';

                        // Create a proper empty line structure
                        const emptyLine = document.createElement('div');
                        emptyLine.className = 'editor-line editing';
                        emptyLine.dataset.lineIndex = '0';

                        // Add zero-width space for cursor visibility
                        const textNode = document.createTextNode('\u200B');
                        emptyLine.appendChild(textNode);
                        this.editor.appendChild(emptyLine);
                    }

                    // Ensure the editor is focusable and properly set up
                    this.editor.setAttribute('contenteditable', 'true');

                    // Force a focus/blur cycle to ensure event handlers are properly attached
                    setTimeout(() => {
                        this.editor.focus();
                        setTimeout(() => {
                            this.editor.blur();
                        }, 50);
                    }, 100);

                    this.isInitialized = true;

                    // Set up periodic health check
                    setInterval(() => this.checkAndFixEditorState(), 5000);
                    setInterval(() => this.ensureCursorVisible(), 1000);

                } catch (error) {
                    // Fallback initialization
                    const fallbackLine = document.createElement('div');
                    fallbackLine.className = 'editor-line editing';
                    fallbackLine.dataset.lineIndex = '0';
                    const textNode = document.createTextNode('\u200B');
                    fallbackLine.appendChild(textNode);
                    this.editor.innerHTML = '';
                    this.editor.appendChild(fallbackLine);
                    this.editor.setAttribute('contenteditable', 'true');
                    this.isInitialized = true;
                }
            }  
          // FIX: Render entire content as formatted with arrow rendering in initialization
            renderFormattedContent(content) {
                const lines = content.split('\n');
                this.editor.innerHTML = '';

                let actualLineIndex = 0;
                lines.forEach((line, index) => {
                    // Skip completely empty lines at the beginning and end, but preserve intentional empty lines
                    if (line.trim() === '' && (index === 0 || index === lines.length - 1)) {
                        return;
                    }

                    const lineDiv = document.createElement('div');
                    lineDiv.className = 'editor-line';
                    lineDiv.dataset.lineIndex = actualLineIndex++;

                    if (line.trim() === '') {
                        const textNode = document.createTextNode('\u200B');
                        lineDiv.appendChild(textNode);
                    } else {
                        const formattedElement = this.renderer.parseLine(line);

                        // Check if this is a heading
                        const isHeading = this.isHeadingLine(line);

                        if (isHeading) {
                            lineDiv.classList.add('heading');
                            lineDiv.dataset.headingLevel = isHeading;

                            // Get the formatted heading element
                            if (formattedElement.tagName === 'DIV') {
                                lineDiv.innerHTML = formattedElement.innerHTML;
                            } else {
                                lineDiv.appendChild(formattedElement);
                            }

                            // FIX: Add arrow rendering to initialization - Now add the arrow INSIDE the heading element
                            const headingElement = lineDiv.querySelector('h1, h2, h3, h4, h5, h6');
                            if (headingElement) {
                                this.addCollapseArrow(headingElement, lineDiv);
                            }
                        } else {
                            // Not a heading, add content normally
                            if (formattedElement.tagName === 'DIV') {
                                lineDiv.innerHTML = formattedElement.innerHTML;
                            } else {
                                lineDiv.appendChild(formattedElement);
                            }
                        }
                    }

                    this.editor.appendChild(lineDiv);
                });

                // Update line numbers after rendering content
                setTimeout(() => {
                    this.updateLineNumbersNow();
                }, 50);
            }      
      // Check if a line is a heading and return its level
            isHeadingLine(line) {
                const headingMatch = line.match(/^(#{1,6})\s/);
                const result = headingMatch ? headingMatch[1].length : false;
                return result;
            }

            // FIX: Fixed duplicate line in addCollapseArrow function
            addCollapseArrow(headingElement, lineDiv) {
                // Check if arrow already exists to prevent duplicates
                if (headingElement.querySelector('.collapse-arrow')) {
                    return;
                }

                const arrow = document.createElement('span');
                arrow.className = 'collapse-arrow';
                arrow.style.userSelect = 'none';
                arrow.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    setTimeout(() => this.toggleCollapse(lineDiv), 0);
                });
                arrow.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                });
                headingElement.insertBefore(arrow, headingElement.firstChild);
            }

            // Toggle collapse/expand for a heading
            toggleCollapse(headingLine) {
                const arrow = headingLine.querySelector('.collapse-arrow');
                if (!arrow) return;

                const headingLevel = parseInt(headingLine.dataset.headingLevel);
                const isCollapsed = arrow.classList.contains('collapsed');

                if (isCollapsed) {
                    // Expand
                    arrow.classList.remove('collapsed');
                    this.expandSection(headingLine, headingLevel);
                    headingLine.classList.remove('has-collapsed-content');
                } else {
                    // Before collapsing, ensure there's always an editable line available
                    const allLines = this.editor.querySelectorAll('.editor-line');
                    const visibleLines = Array.from(allLines).filter(line => !line.classList.contains('collapsed'));

                    // If this would be the only visible line after collapse, add a safety line
                    if (visibleLines.length <= 1) {
                        const safetyLine = document.createElement('div');
                        safetyLine.className = 'editor-line';
                        const textNode = document.createTextNode('\u200B');
                        safetyLine.appendChild(textNode);
                        safetyLine.dataset.lineIndex = allLines.length;
                        this.editor.appendChild(safetyLine);
                    }

                    // Collapse
                    arrow.classList.add('collapsed');
                    this.collapseSection(headingLine, headingLevel);
                    headingLine.classList.add('has-collapsed-content');
                }
            }       
     // Enhanced collapse section that preserves nested heading states
            collapseSection(headingLine, headingLevel) {
                let currentLine = headingLine.nextElementSibling;

                while (currentLine) {
                    const currentLineText = this.getLineRawContent(currentLine);
                    const currentHeadingLevel = this.isHeadingLine(currentLineText);

                    // Stop if we hit a heading of equal or higher level (lower number)
                    if (currentHeadingLevel && currentHeadingLevel <= headingLevel) {
                        break;
                    }

                    const nextLine = currentLine.nextElementSibling;
                    
                    // Store the current state of nested headings before hiding
                    if (currentLine.classList.contains('heading')) {
                        const nestedArrow = currentLine.querySelector('.collapse-arrow');
                        if (nestedArrow) {
                            currentLine.dataset.wasCollapsed = nestedArrow.classList.contains('collapsed').toString();
                        }
                    }
                    
                    // Hide this line
                    currentLine.classList.add('collapsed');
                    currentLine = nextLine;
                }

                // Update line numbers after collapsing
                this.updateLineNumbers();
            }

            // Enhanced expand section that preserves nested heading states
            expandSection(headingLine, headingLevel) {
                let currentLine = headingLine.nextElementSibling;

                while (currentLine) {
                    // Check if this line should stop the expansion
                    const currentLineText = this.getLineRawContent(currentLine);
                    const currentHeadingLevel = this.isHeadingLine(currentLineText);

                    // Stop if we hit a heading of equal or higher level (lower number)
                    if (currentHeadingLevel && currentHeadingLevel <= headingLevel) {
                        break;
                    }

                    const nextLine = currentLine.nextElementSibling;
                    
                    // Show this line if it was collapsed by THIS heading
                    if (currentLine.classList.contains('collapsed')) {
                        currentLine.classList.remove('collapsed');
                        
                        // If this is a nested heading that was previously collapsed, 
                        // restore its previous collapse state
                        if (currentLine.classList.contains('heading')) {
                            const nestedArrow = currentLine.querySelector('.collapse-arrow');
                            if (nestedArrow) {
                                const wasNestedCollapsed = currentLine.dataset.wasCollapsed === 'true';
                                if (wasNestedCollapsed) {
                                    nestedArrow.classList.add('collapsed');
                                    currentLine.classList.add('has-collapsed-content');
                                } else {
                                    nestedArrow.classList.remove('collapsed');
                                    currentLine.classList.remove('has-collapsed-content');
                                }
                                // Clean up the temporary data
                                delete currentLine.dataset.wasCollapsed;
                            }
                        }
                    }

                    currentLine = nextLine;
                }

                // Update line numbers after expanding
                this.updateLineNumbers();
            }            
// Update line numbers (with optional immediate mode for rapid operations)
            updateLineNumbers(immediate = false) {
                if (immediate) {
                    // Immediate update for rapid operations
                    if (window.updateAll) {
                        window.updateAll();
                    }
                } else {
                    // Delayed update for normal operations
                    setTimeout(() => {
                        if (window.updateAll) {
                            window.updateAll();
                        }
                    }, 0);
                }
            }

            // Force immediate line number update (for rapid operations)
            updateLineNumbersImmediate() {
                this.updateLineNumbers(true);
            }

            // Check and fix editor state if needed
            checkAndFixEditorState() {
                // Check if editor has proper structure
                const lines = this.editor.querySelectorAll('.editor-line');
                if (lines.length === 0) {
                    this.createMinimumStructure();
                }

                // Ensure contenteditable is set
                if (this.editor.getAttribute('contenteditable') !== 'true') {
                    this.editor.setAttribute('contenteditable', 'true');
                }
            }

            // Ensure minimum structure exists
            ensureMinimumStructure() {
                const lines = this.editor.querySelectorAll('.editor-line');
                if (lines.length === 0) {
                    this.createMinimumStructure();
                }
            }

            // Create the minimum required structure
            createMinimumStructure() {
                const emptyLine = document.createElement('div');
                emptyLine.className = 'editor-line editing';
                emptyLine.dataset.lineIndex = '0';

                // Add zero-width space for better cursor visibility
                const textNode = document.createTextNode('\u200B');
                emptyLine.appendChild(textNode);

                this.editor.appendChild(emptyLine);

                // Position cursor in the new line
                setTimeout(() => {
                    const range = document.createRange();
                    const selection = window.getSelection();
                    range.setStart(textNode, 0);
                    range.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(range);
                    this.editor.focus();
                }, 0);
            }     
       // Check if select-all is active
            isSelectAllActive() {
                const selection = window.getSelection();
                if (!selection.rangeCount) return false;

                const range = selection.getRangeAt(0);
                const selectedText = range.toString();
                const allText = this.editor.textContent || '';

                // Check if all or most content is selected
                return selectedText.length > 0 && selectedText.length >= allText.length * 0.9;
            }

            // Handle select-all delete safely
            handleSelectAllDelete() {
                // Clear all content but maintain structure
                this.editor.innerHTML = '';
                this.createMinimumStructure();

                // Ensure cursor is positioned at the start for immediate typing
                setTimeout(() => {
                    const firstLine = this.editor.querySelector('.editor-line');
                    if (firstLine) {
                        // Make sure the line is in edit mode with proper cursor support
                        firstLine.classList.add('editing');

                        // Clear and add zero-width space for cursor visibility
                        firstLine.innerHTML = '';
                        firstLine.textContent = '';
                        const textNode = document.createTextNode('\u200B');
                        firstLine.appendChild(textNode);

                        this.currentEditingLineElement = firstLine;

                        // Position cursor at the start of the line
                        const range = document.createRange();
                        const selection = window.getSelection();

                        range.setStart(textNode, 0);
                        range.collapse(true);

                        selection.removeAllRanges();
                        selection.addRange(range);

                        // Focus the editor to ensure cursor is visible
                        this.editor.focus();
                    }
                }, 50); // Slightly longer delay to ensure DOM is ready

                // Update line numbers and status
                this.updateLineNumbers();
            }

            // Ensure cursor is visible and properly positioned
            ensureCursorVisible() {
                try {
                    const selection = window.getSelection();

                    // Check if we have a valid selection
                    if (!selection.rangeCount) {
                        this.restoreCursor();
                        return;
                    }

                    // Check if the selection is within the editor
                    const range = selection.getRangeAt(0);
                    if (!this.editor.contains(range.commonAncestorContainer)) {
                        this.restoreCursor();
                        return;
                    }

                    // Check if cursor is in a valid line
                    const currentLine = this.getCurrentLineElement();
                    if (!currentLine) {
                        this.restoreCursor();
                        return;
                    }

                    // Additional check: ensure the line is still in the DOM
                    if (!currentLine.parentNode) {
                        this.restoreCursor();
                        return;
                    }
                } catch (error) {
                    // Fallback: try to restore cursor
                    setTimeout(() => this.restoreCursor(), 10);
                }
            }           
 // Restore cursor to a safe position
            restoreCursor() {
                // Find the current editing line or create one
                let targetLine = this.currentEditingLineElement;

                if (!targetLine || !targetLine.parentNode) {
                    // Find any available line
                    const lines = this.editor.querySelectorAll('.editor-line');
                    if (lines.length > 0) {
                        targetLine = lines[lines.length - 1]; // Use last line
                    } else {
                        // Create a new line if none exist
                        this.createMinimumStructure();
                        targetLine = this.editor.querySelector('.editor-line');
                    }
                }

                if (targetLine) {
                    // Ensure the line is in edit mode
                    if (!targetLine.classList.contains('editing')) {
                        this.makeLineEditable(targetLine);
                    }

                    // Position cursor at the end of the line
                    const textContent = targetLine.textContent || '';
                    this.setCursorInLineSafe(targetLine, textContent.length);

                    // Update current editing line reference
                    this.currentEditingLineElement = targetLine;
                }
            }

            // Enhanced cursor positioning with error handling
            setCursorInLineSafe(lineElement, position) {
                try {
                    this.setCursorInLine(lineElement, position);
                } catch (error) {
                    // Fallback: just focus the editor
                    this.editor.focus();

                    // Try to restore cursor after a delay
                    setTimeout(() => {
                        this.restoreCursor();
                    }, 10);
                }
            }

            // Handle input changes
            handleInput(e) {
                const currentLine = this.getCurrentLineElement();
                if (!currentLine) return;

                // FIX: Improved undo system - save state every 5 words instead of time-based
                this.handleUndoSaveOnInput();

                // FIX: Only schedule delayed formatting for lists (less aggressive approach)
                this.scheduleDelayedListFormatting(currentLine);

                // Clean up zero-width spaces when user starts typing
                const content = currentLine.textContent || '';
                if (content.includes('\u200B') && content.length > 1) {
                    // Get the current cursor position before cleaning
                    const selection = window.getSelection();
                    let cursorOffset = 0;

                    if (selection.rangeCount > 0) {
                        const range = selection.getRangeAt(0);
                        if (range.startContainer.nodeType === Node.TEXT_NODE) {
                            cursorOffset = range.startOffset;
                        }
                    }

                    // Remove zero-width spaces when there's actual content
                    const cleanContent = content.replace(/\u200B/g, '');

                    // Set clean content
                    currentLine.textContent = cleanContent;

                    // Position cursor correctly - if we were at position 1 (after zero-width space),
                    // we should now be at position 1 in the clean content (after the first character)
                    setTimeout(() => {
                        if (currentLine.firstChild && currentLine.firstChild.nodeType === Node.TEXT_NODE) {
                            const range = document.createRange();
                            const sel = window.getSelection();
                            const textNode = currentLine.firstChild;

                            // If cursor was after the zero-width space (position 1), keep it at position 1
                            // If cursor was at the zero-width space (position 0), move it to position 1
                            const targetPos = Math.max(1, cursorOffset);
                            const finalPos = Math.min(targetPos, textNode.textContent.length);

                            range.setStart(textNode, finalPos);
                            range.collapse(true);
                            sel.removeAllRanges();
                            sel.addRange(range);
                        }
                    }, 0);
                }

                // Update the current line's content
                this.updateCurrentLineContent();
            }

            // FIX: Handle undo save based on word count instead of time
            handleUndoSaveOnInput() {
                const currentContent = this.getAllContent();
                const words = currentContent.trim().split(/\s+/).filter(word => word.length > 0);
                
                // Initialize word count tracking if not exists
                if (!this.lastWordCount) {
                    this.lastWordCount = 0;
                }
                
                // Save state every 5 words
                if (words.length >= this.lastWordCount + 5) {
                    this.saveState();
                    this.lastWordCount = words.length;
                }
            }

            // FIX: Force immediate re-render for lists with formatting
            handleImmediateListRerender(currentLine) {
                if (!currentLine) return;
                
                const content = currentLine.textContent || '';
                
                // Check if this is a list item with potential formatting
                const isUnorderedList = content.match(/^(\s*)[-*+] (.+)$/);
                const isOrderedList = content.match(/^(\s*)(\d+)\. (.+)$/);
                
                if ((isUnorderedList || isOrderedList) && content.includes('**')) {
                    // Schedule immediate re-render for lists with bold formatting
                    setTimeout(() => {
                        if (!currentLine.classList.contains('editing')) {
                            // Line is already formatted, force re-render to ensure bold text shows
                            const rawContent = this.getLineRawContent(currentLine);
                            const formattedElement = this.renderer.parseLine(rawContent);
                            
                            // Clear and re-add content
                            currentLine.innerHTML = '';
                            if (formattedElement.tagName === 'DIV') {
                                currentLine.innerHTML = formattedElement.innerHTML;
                            } else {
                                currentLine.appendChild(formattedElement);
                            }
                        }
                    }, 10);
                }
            }

            // FIX: Schedule delayed formatting for lists (triggers after user stops typing)
            scheduleDelayedListFormatting(currentLine) {
                if (!currentLine) return;
                
                // Clear any existing timeout
                if (this.delayedFormatTimeout) {
                    clearTimeout(this.delayedFormatTimeout);
                }
                
                // Set new timeout to format after 1 second of no typing (longer delay to avoid cursor issues)
                this.delayedFormatTimeout = setTimeout(() => {
                    const content = currentLine.textContent || '';
                    const isUnorderedList = content.match(/^(\s*)[-*+] (.+)$/);
                    const isOrderedList = content.match(/^(\s*)(\d+)\. (.+)$/);
                    
                    if ((isUnorderedList || isOrderedList) && content.includes('**') && currentLine.classList.contains('editing')) {
                        // Only format if the user is not actively typing (check if line still has focus)
                        const selection = window.getSelection();
                        if (selection.rangeCount > 0 && currentLine.contains(selection.getRangeAt(0).commonAncestorContainer)) {
                            // User is still in this line, don't format yet
                            return;
                        }
                        
                        // Temporarily format the line to show bold text
                        this.formatLine(currentLine);
                        
                        // Switch back to edit mode after a brief moment
                        setTimeout(() => {
                            this.makeLineEditable(currentLine);
                        }, 100);
                    }
                }, 1000);
            }     
       // Handle selection changes to switch between raw/formatted lines
            handleSelectionChange() {
                // Add a small delay to ensure DOM is stable
                setTimeout(() => {
                    const selection = window.getSelection();
                    if (!selection.rangeCount) return;

                    // Check if user is making a text selection (not just clicking)
                    const range = selection.getRangeAt(0);
                    const isTextSelection = !range.collapsed; // Range is not collapsed = text is selected

                    // Don't interfere with text selection - let user highlight text
                    if (isTextSelection) {
                        return;
                    }

                    const newLineElement = this.getCurrentLineElement();

                    // Only proceed if we actually have a line element
                    if (!newLineElement) return;

                    // Don't switch to edit mode if we're clicking on a collapse arrow
                    const clickedElement = range.startContainer.nodeType === Node.TEXT_NODE
                        ? range.startContainer.parentNode
                        : range.startContainer;

                    if (clickedElement && (clickedElement.classList.contains('collapse-arrow') ||
                        clickedElement.closest('.collapse-arrow'))) {
                        return;
                    }

                    if (newLineElement !== this.currentEditingLineElement) {
                        // Check if the new line is a collapsed heading - don't allow editing
                        const isCollapsedHeading = newLineElement.classList.contains('heading') &&
                            newLineElement.classList.contains('has-collapsed-content');

                        if (isCollapsedHeading) {
                            return;
                        }

                        // Format the previous line if it exists
                        if (this.currentEditingLineElement && this.currentEditingLineElement.parentNode) {
                            this.formatLine(this.currentEditingLineElement);
                            
                            // FIX: Apply double-render for lists when switching lines
                            this.applyDoubleRenderForLists(this.currentEditingLineElement);
                        }

                        // Switch to raw mode for new line
                        this.makeLineEditable(newLineElement);
                        this.currentEditingLineElement = newLineElement;
                    }

                    // Line numbers will update automatically via MutationObserver
                }, 10);
            }

            // Get the current line element containing the cursor
            getCurrentLineElement() {
                const selection = window.getSelection();
                if (!selection.rangeCount) return null;

                let node = selection.getRangeAt(0).startContainer;

                // If we're in a text node, get its parent
                if (node.nodeType === Node.TEXT_NODE) {
                    node = node.parentNode;
                }

                // Walk up to find the line div
                let attempts = 0;
                while (node && node !== this.editor && attempts < 10) {
                    if (node.nodeType === Node.ELEMENT_NODE && node.classList && node.classList.contains('editor-line')) {
                        return node;
                    }
                    node = node.parentNode;
                    attempts++;
                }

                // Fallback: if we can't find the line, try to find it by position
                const lines = this.editor.querySelectorAll('.editor-line');
                if (lines.length === 0) return null;

                // Return the first line as fallback
                return lines[0];
            }      
      // Make a line editable (show raw markdown)
            makeLineEditable(lineElement) {
                // Don't switch to edit mode if already editing
                if (lineElement.classList.contains('editing')) {
                    return;
                }

                const rawContent = this.getLineRawContent(lineElement);

                // Special handling for blank lines
                const isBlankLine = rawContent.trim() === '';

                if (isBlankLine) {
                    // For blank lines, clear content but ensure cursor visibility
                    lineElement.innerHTML = '';
                    lineElement.textContent = '';
                    lineElement.classList.add('editing');

                    // Ensure the line has proper structure for cursor visibility
                    // Add a zero-width space to make the line focusable
                    const textNode = document.createTextNode('\u200B'); // Zero-width space
                    lineElement.appendChild(textNode);

                    // Position cursor at start of blank line
                    setTimeout(() => {
                        const range = document.createRange();
                        const selection = window.getSelection();
                        range.setStart(textNode, 0);
                        range.collapse(true);
                        selection.removeAllRanges();
                        selection.addRange(range);

                        // Focus the editor to ensure cursor is visible
                        this.editor.focus();
                    }, 0);
                    return;
                }

                // Store cursor position as a ratio of the visible text length
                const selection = window.getSelection();
                let cursorRatio = 1; // Default to end of line
                if (selection.rangeCount > 0) {
                    const range = selection.getRangeAt(0);
                    if (lineElement.contains(range.startContainer)) {
                        const visibleText = lineElement.textContent || '';
                        const cursorPos = this.getCursorPositionInLine(lineElement);
                        cursorRatio = visibleText.length > 0 ? cursorPos / visibleText.length : 1;
                    }
                }

                // Simply set the text content - arrows will be re-added when formatting
                lineElement.innerHTML = '';
                lineElement.textContent = rawContent;
                lineElement.classList.add('editing');

                // Restore cursor position based on ratio
                setTimeout(() => {
                    const targetPos = Math.floor(rawContent.length * cursorRatio);
                    this.setCursorInLineSafe(lineElement, Math.min(targetPos, rawContent.length));
                }, 0);
            } 
           // Format a line (show formatted content)
            formatLine(lineElement) {
                const rawContent = lineElement.textContent || '';
                lineElement.classList.remove('editing');

                // Preserve collapse arrow if it exists
                const existingArrow = lineElement.querySelector('.collapse-arrow');
                const wasCollapsed = existingArrow && existingArrow.classList.contains('collapsed');

                if (rawContent.trim() === '') {
                    lineElement.innerHTML = '';
                    const textNode = document.createTextNode('\u200B');
                    lineElement.appendChild(textNode);
                } else {
                    const formattedElement = this.renderer.parseLine(rawContent);

                    // Check if this is a heading
                    const isHeading = this.isHeadingLine(rawContent);
                    if (isHeading) {
                        lineElement.classList.add('heading');
                        lineElement.dataset.headingLevel = isHeading;

                        // Clear content first
                        lineElement.innerHTML = '';

                        // Add formatted content
                        if (formattedElement.tagName === 'DIV') {
                            lineElement.innerHTML = formattedElement.innerHTML;
                        } else {
                            lineElement.appendChild(formattedElement);
                        }

                        // FIX: Add arrow rendering to re-rendering loop - Now add the arrow INSIDE the heading element
                        const headingElement = lineElement.querySelector('h1, h2, h3, h4, h5, h6');
                        if (headingElement) {
                            this.addCollapseArrow(headingElement, lineElement);
                            if (wasCollapsed) {
                                const arrow = headingElement.querySelector('.collapse-arrow');
                                arrow.classList.add('collapsed');
                                lineElement.classList.add('has-collapsed-content');
                            }
                        }
                    } else {
                        // Not a heading, remove heading classes
                        lineElement.classList.remove('heading', 'has-collapsed-content');
                        delete lineElement.dataset.headingLevel;
                        lineElement.innerHTML = '';

                        if (formattedElement.tagName === 'DIV') {
                            lineElement.innerHTML = formattedElement.innerHTML;
                        } else {
                            lineElement.appendChild(formattedElement);
                        }
                    }
                }

                // FIX: Enhanced double-render logic for both ordered and unordered lists
                setTimeout(() => {
                    const isUnorderedList = rawContent.match(/^(\s*)[-*+] (.+)$/);
                    const isOrderedList = rawContent.match(/^(\s*)(\d+)\. (.+)$/);
                    
                    if (isUnorderedList || isOrderedList) {
                        // First render
                        const newFormattedElement = this.renderer.parseLine(rawContent);
                        lineElement.innerHTML = '';
                        if (newFormattedElement.tagName === 'DIV') {
                            lineElement.innerHTML = newFormattedElement.innerHTML;
                        } else {
                            lineElement.appendChild(newFormattedElement);
                        }
                        
                        // FIX: Second render for better formatting consistency (same logic for both list types)
                        setTimeout(() => {
                            const secondFormattedElement = this.renderer.parseLine(rawContent);
                            lineElement.innerHTML = '';
                            if (secondFormattedElement.tagName === 'DIV') {
                                lineElement.innerHTML = secondFormattedElement.innerHTML;
                            } else {
                                lineElement.appendChild(secondFormattedElement);
                            }
                        }, 25);
                    }
                }, 0);

                // Line numbers will update automatically via MutationObserver when content changes
            }  
          // FIX: Fixed getLineRawContent to call extractLineMarkdown instead of extractMarkdown
            getLineRawContent(lineElement) {
                if (lineElement.classList.contains('editing')) {
                    const content = lineElement.textContent || '';
                    // Remove zero-width spaces used for cursor visibility
                    return content.replace(/\u200B/g, '');
                }

                // Check if this is an empty line (only contains <br> or zero-width space)
                if (lineElement.innerHTML === '<br>' || lineElement.innerHTML.trim() === '<br>' ||
                    lineElement.textContent === '\u200B') {
                    return ''; // Return empty string, not newline
                }

                // For headings with arrows, extract text from the heading element
                const headingElement = lineElement.querySelector('h1, h2, h3, h4, h5, h6');
                if (headingElement) {
                    // Get the heading level from the tag name
                    const level = parseInt(headingElement.tagName.charAt(1));
                    const prefix = '#'.repeat(level) + ' ';

                    // Get text content, excluding the arrow
                    let text = '';
                    for (let node of headingElement.childNodes) {
                        if (node.nodeType === Node.TEXT_NODE) {
                            text += node.textContent;
                        } else if (node.nodeType === Node.ELEMENT_NODE && !node.classList.contains('collapse-arrow')) {
                            text += node.textContent;
                        }
                    }
                    return prefix + text.trim();
                }

                // FIX: For non-headings, use extractLineMarkdown instead of extractMarkdown
                return this.renderer.extractLineMarkdown(lineElement) || lineElement.textContent || '';
            }

            // Format all lines (used on blur)
            formatAllLines() {
                const lines = this.editor.querySelectorAll('.editor-line');
                lines.forEach(line => {
                    if (line.classList.contains('editing')) {
                        this.formatLine(line);
                    }
                });
                this.currentEditingLineElement = null;
            }

            // FIX: Add arrow rendering to forceRenderAllLines function
            forceRenderAllLines() {
                const lines = this.editor.querySelectorAll('.editor-line');
                lines.forEach(line => {
                    // Get raw content
                    const rawContent = this.getLineRawContent(line);

                    // Re-render the line
                    if (rawContent.trim() === '') {
                        line.innerHTML = '';
                        const textNode = document.createTextNode('\u200B');
                        line.appendChild(textNode);
                    } else {
                        const formattedElement = this.renderer.parseLine(rawContent);
                        line.classList.remove('editing');
                        line.innerHTML = '';

                        if (formattedElement.tagName === 'DIV') {
                            line.innerHTML = formattedElement.innerHTML;
                        } else {
                            line.appendChild(formattedElement);
                        }

                        // FIX: Add arrow rendering to forceRenderAllLines - Check if this is a heading and add arrow
                        const isHeading = this.isHeadingLine(rawContent);
                        if (isHeading) {
                            line.classList.add('heading');
                            line.dataset.headingLevel = isHeading;

                            const headingElement = line.querySelector('h1, h2, h3, h4, h5, h6');
                            if (headingElement) {
                                this.addCollapseArrow(headingElement, line);
                            }
                        }
                    }
                });

                // Force line number update after re-rendering (this is intentional)
                this.scheduleLineNumberUpdate();
            } 
           // Update current line content and handle line breaks
            updateCurrentLineContent() {
                const currentLine = this.currentEditingLineElement;
                if (!currentLine) return;

                const content = currentLine.textContent || '';
                const lines = content.split('\n');

                if (lines.length > 1) {
                    // Handle line breaks - split into multiple lines
                    this.splitLine(currentLine, lines);
                }
            }

            // Split a line into multiple lines
            splitLine(lineElement, lines) {
                const lineIndex = parseInt(lineElement.dataset.lineIndex);
                const selection = window.getSelection();
                const cursorPos = this.getCursorPositionInLine(lineElement);

                // Update current line with first part
                lineElement.textContent = lines[0];

                // Insert new lines for the rest
                lines.slice(1).forEach((line, index) => {
                    const newLineDiv = document.createElement('div');
                    newLineDiv.className = 'editor-line';
                    newLineDiv.dataset.lineIndex = lineIndex + index + 1;
                    newLineDiv.textContent = line;

                    lineElement.parentNode.insertBefore(newLineDiv, lineElement.nextSibling);
                    lineElement = newLineDiv; // Update reference for next iteration
                });

                // Update line indices for all subsequent lines
                this.updateLineIndices();

                // Restore cursor position in the new line
                const newCurrentLine = this.editor.querySelector(`[data-line-index="${lineIndex + 1}"]`);
                if (newCurrentLine) {
                    this.setCursorInLine(newCurrentLine, 0);
                    this.currentEditingLineElement = newCurrentLine;
                    this.makeLineEditable(newCurrentLine);
                }
            }

            // Update line indices after splitting/merging
            updateLineIndices() {
                const lines = this.editor.querySelectorAll('.editor-line');
                lines.forEach((line, index) => {
                    line.dataset.lineIndex = index;
                });
            }

            // Get cursor position within a line
            getCursorPositionInLine(lineElement) {
                const selection = window.getSelection();
                if (!selection.rangeCount) return 0;

                const range = selection.getRangeAt(0);
                const preCaretRange = range.cloneRange();
                preCaretRange.selectNodeContents(lineElement);
                preCaretRange.setEnd(range.endContainer, range.endOffset);

                return preCaretRange.toString().length;
            }     
       // Set cursor position within a line
            setCursorInLine(lineElement, position) {
                const selection = window.getSelection();
                const range = document.createRange();

                let currentPos = 0;
                const walker = document.createTreeWalker(
                    lineElement,
                    NodeFilter.SHOW_TEXT,
                    null,
                    false
                );

                let node;
                while (node = walker.nextNode()) {
                    const nodeLength = node.textContent.length;
                    if (currentPos + nodeLength >= position) {
                        range.setStart(node, Math.min(position - currentPos, nodeLength));
                        range.setEnd(node, Math.min(position - currentPos, nodeLength));
                        break;
                    }
                    currentPos += nodeLength;
                }

                selection.removeAllRanges();
                selection.addRange(range);
            }

            // Get all content as raw markdown
            getAllContent() {
                const lines = this.editor.querySelectorAll('.editor-line');
                const content = [];

                lines.forEach((line, index) => {
                    const rawContent = this.getLineRawContent(line);
                    content.push(rawContent);
                });

                const result = content.join('\n');
                return result;
            }

            // Check if currently in edit mode (always true for line-based editing)
            isEditing() {
                return true; // Always in edit mode for line-based editing
            }

            // Debug method to check editor state
            debugEditorState() {
                const lines = this.editor.querySelectorAll('.editor-line');
                lines.forEach((line, i) => {
                    // Debug logging removed for cleaner code
                });
            }

            // Smart line number update scheduling with performance optimization
            scheduleLineNumberUpdate() {
                const now = Date.now();
                const timeSinceLastUpdate = now - this.lastLineNumberUpdate;

                // Detect rapid operations (multiple updates within 200ms)
                if (timeSinceLastUpdate < 200) {
                    this.isRapidOperation = true;
                    // Clear rapid operation flag after a delay
                    if (this.rapidOperationTimeout) {
                        clearTimeout(this.rapidOperationTimeout);
                    }
                    this.rapidOperationTimeout = setTimeout(() => {
                        this.isRapidOperation = false;
                    }, 500);
                }

                // Clear any pending update
                if (this.lineNumberUpdateTimeout) {
                    clearTimeout(this.lineNumberUpdateTimeout);
                }

                // During rapid operations, be more conservative
                if (this.isRapidOperation) {
                    // Longer debounce during rapid operations to prevent cursor issues
                    this.lineNumberUpdateTimeout = setTimeout(() => {
                        this.performLineNumberUpdate();
                    }, 300);
                } else if (timeSinceLastUpdate < 100) {
                    // Normal debounce
                    this.lineNumberUpdateTimeout = setTimeout(() => {
                        this.performLineNumberUpdate();
                    }, 150);
                } else {
                    // If it's been a while, update immediately
                    this.performLineNumberUpdate();
                }
            }    
        // Perform the actual line number update
            performLineNumberUpdate() {
                this.lastLineNumberUpdate = Date.now();
                // Only use our self-contained update, don't call the global system
                this.updateLineNumbersNow();
            }

            // SMART AUTO-MEASURING LINE NUMBER CALCULATION SYSTEM
            // This method measures actual rendered heights and positions line numbers perfectly
            calculateLineNumbers() {
                try {
                    const editorLines = this.editor.querySelectorAll('.editor-line');
                    let lineNumberElements = [];
                    let visibleLineCount = 0;

                    // Measure baseline line height using a dummy element
                    const baseLineHeight = this.measureBaseLineHeight();

                    if (editorLines.length === 0) {
                        return {
                            html: '<div class="line-number" style="top: 0px;">1</div>',
                            total: 1
                        };
                    }

                    const editorRect = this.editor.getBoundingClientRect();

                    // Process each visible line
                    for (let i = 0; i < editorLines.length; i++) {
                        const line = editorLines[i];

                        // Skip collapsed lines
                        if (line.classList.contains('collapsed')) {
                            continue;
                        }

                        visibleLineCount++;
                        const content = line.textContent.substring(0, 30) + (line.textContent.length > 30 ? '...' : '');

                        // Get actual rendered dimensions
                        const lineRect = line.getBoundingClientRect();
                        const relativeTop = lineRect.top - editorRect.top;
                        const lineHeight = lineRect.height;

                        // Calculate how many "text lines" this element represents
                        const textLines = Math.max(1, Math.round(lineHeight / baseLineHeight));

                        // Create ONE line number positioned at the top of this element
                        // Each DOM element (.editor-line) counts as exactly ONE logical line
                        const lineNumberHtml = `<div class="line-number" style="top: ${relativeTop}px;">${visibleLineCount}</div>`;
                        lineNumberElements.push(lineNumberHtml);

                        // Note: We don't create multiple line numbers for tall elements like headers
                        // The visual spacing is handled by the element's natural height
                    }

                    return {
                        html: lineNumberElements.join(''),
                        total: Math.max(1, visibleLineCount)
                    };

                } catch (error) {
                    // Fallback to simple calculation
                    return {
                        html: '<div class="line-number" style="top: 0px;">1</div>',
                        total: 1
                    };
                }
            }

            // Measure baseline line height for text
            measureBaseLineHeight() {
                const dummy = document.createElement('div');
                dummy.textContent = 'Ag'; // Characters with ascenders and descenders
                dummy.style.cssText = `
                    position: absolute;
                    visibility: hidden;
                    font-family: inherit;
                    font-size: inherit;
                    line-height: inherit;
                    margin: 0;
                    padding: 0;
                    border: 0;
                    white-space: nowrap;
                `;

                this.editor.appendChild(dummy);
                const height = dummy.getBoundingClientRect().height;
                dummy.remove();

                return height || 22; // Fallback to 22px if measurement fails
            } 
           // Self-contained line number update that uses the unified calculation
            updateLineNumbersNow() {
                try {
                    const lineNumbers = document.getElementById('lineNumbers');
                    const status = document.getElementById('status');

                    if (!lineNumbers || !status) {
                        return;
                    }

                    // Use smart auto-measuring calculation method
                    const result = this.calculateLineNumbers();

                    // Update line numbers with new HTML structure
                    lineNumbers.innerHTML = result.html;

                    // Update status
                    if (status) {
                        const text = this.getAllContent();
                        const cleanText = this.getCleanTextForCounting(text);
                        const chars = cleanText.length;
                        const words = cleanText.trim() ? cleanText.trim().split(/\s+/).length : 0;
                        const lines = result.total;
                        status.textContent = `Words: ${words} | Characters: ${chars} | Lines: ${lines}`;
                    }
                } catch (error) {
                    // Fallback
                    const lineNumbers = document.getElementById('lineNumbers');
                    if (lineNumbers) {
                        lineNumbers.innerHTML = '<div class="line-number" style="top: 0px;">1</div>';
                    }
                }
            }

            // Get clean text for counting (removes markdown syntax)
            getCleanTextForCounting(text) {
                if (!text) return '';

                return text
                    .replace(/\*\*(.*?)\*\*/g, '$1')  // Bold
                    .replace(/\*(.*?)\*/g, '$1')      // Italic
                    .replace(/~~(.*?)~~/g, '$1')      // Strikethrough
                    .replace(/==(.*?)==/g, '$1')      // Highlight
                    .replace(/^#{1,3}\s+/gm, '')      // Headings
                    .replace(/^(\s*)[-*+]\s+/gm, '$1') // Unordered lists
                    .replace(/^(\s*)\d+\.\s+/gm, '$1') // Ordered lists
                    .replace(/^(---|\*\*\*|___)$/gm, '') // Horizontal rules
                    .replace(/^\s*$/gm, '');          // Empty lines
            }

            // Force line number update with self-contained method only
            forceLineNumberUpdate() {
                this.debugEditorState();

                // Use only our self-contained update to avoid double rendering
                this.updateLineNumbersNow();

                // Single retry if needed
                setTimeout(() => {
                    this.updateLineNumbersNow();
                }, 100);
            }

            // Force complete re-initialization (useful after major content changes)
            forceReinitialize() {
                const content = this.editor.textContent || '';
                this.isInitialized = false;
                this.currentEditingLineElement = null;

                // Clear and reinitialize
                this.editor.innerHTML = '';
                if (content.trim()) {
                    this.editor.textContent = content;
                    this.initializeEditor();
                } else {
                    this.createMinimumStructure();
                }

                // Force line number update with retry logic
                setTimeout(() => this.forceLineNumberUpdate(), 100);
            } 
           // Undo/Redo System
            saveState() {
                const currentState = this.getAllContent();

                // Don't save if it's the same as the last saved state
                if (currentState === this.lastSavedState) {
                    return;
                }

                // Remove any states after current index (when we're in the middle of history)
                this.history = this.history.slice(0, this.historyIndex + 1);

                // Add new state
                this.history.push(currentState);
                this.historyIndex = this.history.length - 1;

                // Limit history size
                if (this.history.length > this.maxHistorySize) {
                    this.history.shift();
                    this.historyIndex--;
                }

                this.lastSavedState = currentState;
            }

            undo() {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    const state = this.history[this.historyIndex];
                    this.restoreState(state);
                    return true;
                }
                return false;
            }

            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.historyIndex++;
                    const state = this.history[this.historyIndex];
                    this.restoreState(state);
                    return true;
                }
                return false;
            }

            restoreState(content) {
                // Temporarily disable state saving during restore
                const originalSaveState = this.saveState;
                this.saveState = () => { };

                try {
                    // Clear editor and set content
                    this.editor.innerHTML = '';
                    this.editor.textContent = content;

                    // Reinitialize with the restored content
                    this.isInitialized = false;
                    this.currentEditingLineElement = null;
                    this.initializeEditor();

                    // Update last saved state to prevent duplicate saves
                    this.lastSavedState = content;
                } finally {
                    // Restore state saving
                    this.saveState = originalSaveState;
                }
            }  
          // Insert markdown syntax at cursor or around selection
            insertMarkdownSyntax(startSyntax, endSyntax = '') {
                const currentLine = this.getCurrentLineElement();
                if (!currentLine) return;

                // Ensure line is in edit mode
                if (!currentLine.classList.contains('editing')) {
                    this.makeLineEditable(currentLine);
                    // Give the line time to switch to edit mode
                    setTimeout(() => {
                        this.insertMarkdownSyntax(startSyntax, endSyntax);
                    }, 10);
                    return;
                }

                const selection = window.getSelection();
                if (!selection.rangeCount) return;

                const range = selection.getRangeAt(0);
                const selectedText = range.toString();

                try {
                    if (selectedText) {
                        // Wrap selected text
                        const wrappedText = startSyntax + selectedText + endSyntax;
                        range.deleteContents();
                        range.insertNode(document.createTextNode(wrappedText));

                        // Position cursor after the inserted text
                        const newRange = document.createRange();
                        newRange.setStartAfter(range.endContainer);
                        newRange.collapse(true);
                        selection.removeAllRanges();
                        selection.addRange(newRange);
                    } else {
                        // Insert syntax at cursor position
                        const syntaxText = startSyntax + endSyntax;
                        const textNode = document.createTextNode(syntaxText);
                        range.insertNode(textNode);

                        // Position cursor between start and end syntax
                        if (endSyntax) {
                            const newRange = document.createRange();
                            newRange.setStart(textNode, startSyntax.length);
                            newRange.collapse(true);
                            selection.removeAllRanges();
                            selection.addRange(newRange);
                        }
                    }
                } catch (error) {
                    // Fallback: just insert the text
                    document.execCommand('insertText', false, startSyntax + (selectedText || '') + endSyntax);
                }
            }

            // Apply formatting to selected text or at cursor
            applyFormatting(type) {
                const currentLine = this.getCurrentLineElement();
                if (!currentLine) return;

                const formatMap = {
                    'bold': ['**', '**'],
                    'italic': ['*', '*'],
                    'strikethrough': ['~~', '~~'],
                    'highlight': ['==', '=='],
                    'h1': ['# ', ''],
                    'h2': ['## ', ''],
                    'h3': ['### ', '']
                };

                if (formatMap[type]) {
                    const [start, end] = formatMap[type];
                    this.insertMarkdownSyntax(start, end);
                }
            } 
           // Remove formatting from selected text
            removeFormatting(type) {
                const currentLine = this.getCurrentLineElement();
                if (!currentLine) return;

                // Ensure line is in edit mode
                if (!currentLine.classList.contains('editing')) {
                    this.makeLineEditable(currentLine);
                }

                const selection = window.getSelection();
                if (!selection.rangeCount) return;

                const range = selection.getRangeAt(0);
                const selectedText = range.toString();

                const formatMap = {
                    'bold': [/^\*\*(.*)\*\*$/, '$1'],
                    'italic': [/^\*(.*)\*$/, '$1'],
                    'strikethrough': [/^~~(.*)~~$/, '$1'],
                    'highlight': [/^==(.*)==$/, '$1'],
                    'h1': [/^# (.*)$/, '$1'],
                    'h2': [/^## (.*)$/, '$1'],
                    'h3': [/^### (.*)$/, '$1']
                };

                if (formatMap[type] && selectedText) {
                    const [pattern, replacement] = formatMap[type];
                    const cleanText = selectedText.replace(pattern, replacement);

                    if (cleanText !== selectedText) {
                        range.deleteContents();
                        range.insertNode(document.createTextNode(cleanText));
                    }
                }
            }

            // Check if selection has specific formatting
            hasFormatting(type) {
                const currentLine = this.getCurrentLineElement();
                if (!currentLine || !currentLine.classList.contains('editing')) return false;

                const selection = window.getSelection();
                if (!selection.rangeCount) return false;

                const selectedText = selection.getRangeAt(0).toString();
                const lineText = currentLine.textContent || '';

                const formatPatterns = {
                    'bold': /^\*\*.*\*\*$/,
                    'italic': /^\*.*\*$/,
                    'strikethrough': /^~~.*~~$/,
                    'highlight': /^==.*==$/,
                    'h1': /^# /,
                    'h2': /^## /,
                    'h3': /^### /
                };

                if (selectedText) {
                    return formatPatterns[type] ? formatPatterns[type].test(selectedText) : false;
                } else {
                    return formatPatterns[type] ? formatPatterns[type].test(lineText) : false;
                }
            }       
     // Handle Enter key for list continuation
            handleEnterKey(e) {
                const currentLineElement = this.getCurrentLineElement();
                if (!currentLineElement) return;

                const currentLineText = currentLineElement.textContent || '';

                // Check if current line is a list item
                const unorderedMatch = currentLineText.match(/^(\s*)[-*+] (.*)$/);
                const orderedMatch = currentLineText.match(/^(\s*)(\d+)\. (.*)$/);

                if (unorderedMatch) {
                    e.preventDefault();
                    const indent = unorderedMatch[1];
                    const content = unorderedMatch[2];

                    if (content.trim() === '') {
                        // Empty list item - exit list mode
                        currentLineElement.textContent = '';
                    } else {
                        // Continue list
                        this.insertNewLineAfter(currentLineElement, indent + '- ');
                        
                        // FIX: Format the previous line AFTER creating new line to avoid cursor issues
                        setTimeout(() => {
                            this.forceFormatPreviousLineForLists(currentLineElement);
                        }, 10);
                    }
                } else if (orderedMatch) {
                    e.preventDefault();
                    const indent = orderedMatch[1];
                    const number = parseInt(orderedMatch[2]);
                    const content = orderedMatch[3];

                    if (content.trim() === '') {
                        // Empty list item - exit list mode
                        currentLineElement.textContent = '';
                    } else {
                        // Continue list with next number
                        this.insertNewLineAfter(currentLineElement, indent + (number + 1) + '. ');
                        
                        // FIX: Format the previous line AFTER creating new line to avoid cursor issues
                        setTimeout(() => {
                            this.forceFormatPreviousLineForLists(currentLineElement);
                        }, 10);
                    }
                } else {
                    // Regular line break - ensure it works properly
                    // If the editor isn't properly initialized, force create a new line
                    if (!this.isInitialized) {
                        e.preventDefault();
                        this.insertNewLineAfter(currentLineElement, '');
                        return;
                    }

                    // Let default behavior handle it, but ensure it works
                    // The input handler will split the line automatically
                }
            }

            // FIX: Force format current line if it's a list with formatting
            forceFormatCurrentLineForLists(lineElement) {
                if (!lineElement || !lineElement.classList.contains('editing')) return;
                
                const content = lineElement.textContent || '';
                const isUnorderedList = content.match(/^(\s*)[-*+] (.+)$/);
                const isOrderedList = content.match(/^(\s*)(\d+)\. (.+)$/);
                
                // If it's a list with bold formatting, force immediate format
                if ((isUnorderedList || isOrderedList) && content.includes('**')) {
                    // Temporarily format the line to render bold text
                    setTimeout(() => {
                        this.formatLine(lineElement);
                        // Then immediately switch back to edit mode after a brief delay
                        setTimeout(() => {
                            this.makeLineEditable(lineElement);
                        }, 50);
                    }, 10);
                }
            }

            // FIX: Format previous line after Enter without interfering with cursor
            forceFormatPreviousLineForLists(currentLineElement) {
                if (!currentLineElement) return;
                
                const content = currentLineElement.textContent || '';
                const isUnorderedList = content.match(/^(\s*)[-*+] (.+)$/);
                const isOrderedList = content.match(/^(\s*)(\d+)\. (.+)$/);
                
                // If it's a list with bold formatting, just format it (don't switch back to edit)
                if ((isUnorderedList || isOrderedList) && content.includes('**')) {
                    // Format the line to show bold text, but don't switch back to edit mode
                    this.formatLine(currentLineElement);
                }
            }

            // FIX: Apply double-render logic for lists when switching lines
            applyDoubleRenderForLists(lineElement) {
                if (!lineElement || lineElement.classList.contains('editing')) return;
                
                const rawContent = this.getLineRawContent(lineElement);
                const isUnorderedList = rawContent.match(/^(\s*)[-*+] (.+)$/);
                const isOrderedList = rawContent.match(/^(\s*)(\d+)\. (.+)$/);
                
                if ((isUnorderedList || isOrderedList) && rawContent.includes('**')) {
                    // Apply the same double-render logic used in formatLine
                    setTimeout(() => {
                        const formattedElement = this.renderer.parseLine(rawContent);
                        lineElement.innerHTML = '';
                        if (formattedElement.tagName === 'DIV') {
                            lineElement.innerHTML = formattedElement.innerHTML;
                        } else {
                            lineElement.appendChild(formattedElement);
                        }
                        
                        // Second render for consistency
                        setTimeout(() => {
                            const secondFormattedElement = this.renderer.parseLine(rawContent);
                            lineElement.innerHTML = '';
                            if (secondFormattedElement.tagName === 'DIV') {
                                lineElement.innerHTML = secondFormattedElement.innerHTML;
                            } else {
                                lineElement.appendChild(secondFormattedElement);
                            }
                        }, 25);
                    }, 10);
                }
            }

            // Handle Backspace key for proper line merging and deletion
            handleBackspaceKey(e) {
                const selection = window.getSelection();
                if (!selection.rangeCount) return;

                const range = selection.getRangeAt(0);
                const currentLineElement = this.getCurrentLineElement();
                if (!currentLineElement) return;

                const currentContent = this.getLineRawContent(currentLineElement);
                const cursorPos = this.getCursorPositionInLine(currentLineElement);

                // Check if we should delete the entire line
                if (currentContent.trim() === '' && cursorPos === 0) {
                    // Empty line - delete it if there are other lines
                    const allLines = this.editor.querySelectorAll('.editor-line');
                    if (allLines.length > 1) {
                        e.preventDefault();
                        this.deleteCurrentLine(currentLineElement, 'previous');
                        return;
                    } else {
                        // Only line left - don't delete, just ensure cursor is visible
                        e.preventDefault();

                        // Clear the line but keep it editable with proper cursor support
                        currentLineElement.innerHTML = '';
                        currentLineElement.textContent = '';
                        currentLineElement.classList.add('editing');

                        // Add zero-width space for cursor visibility
                        const textNode = document.createTextNode('\u200B');
                        currentLineElement.appendChild(textNode);

                        // Position cursor and focus with better error handling
                        setTimeout(() => {
                            try {
                                const range = document.createRange();
                                const selection = window.getSelection();
                                range.setStart(textNode, 0);
                                range.collapse(true);
                                selection.removeAllRanges();
                                selection.addRange(range);
                                this.editor.focus();
                            } catch (error) {
                                // Fallback: just focus the editor
                                this.editor.focus();
                            }
                        }, 0);
                        return;
                    }
                }         
       // Check if cursor is at the beginning of the line (merge with previous)
                if (cursorPos === 0) {
                    // Cursor is at the beginning of the line
                    const previousLine = currentLineElement.previousElementSibling;

                    if (previousLine && previousLine.classList.contains('editor-line')) {
                        e.preventDefault();

                        // Get content of both lines
                        const currentContent = this.getLineRawContent(currentLineElement);
                        const previousContent = this.getLineRawContent(previousLine);

                        // Merge content
                        const mergedContent = previousContent + currentContent;

                        // Update previous line with merged content
                        if (previousLine.classList.contains('editing')) {
                            previousLine.textContent = mergedContent;
                        } else {
                            // Switch previous line to edit mode and set content
                            this.makeLineEditable(previousLine);
                            previousLine.textContent = mergedContent;
                        }

                        // Position cursor at the junction point (end of previous content)
                        this.setCursorInLine(previousLine, previousContent.length);

                        // Remove current line
                        currentLineElement.remove();

                        // Update line indices
                        this.updateLineIndices();

                        // Update current editing line reference
                        this.currentEditingLineElement = previousLine;

                        // Ensure cursor remains visible after DOM changes
                        setTimeout(() => {
                            this.ensureCursorVisible();
                            this.setCursorInLine(previousLine, previousContent.length);
                        }, 0);

                        // Update line numbers immediately for rapid operations
                        this.updateLineNumbersImmediate();
                    }
                }
                // If cursor is not at beginning, let default backspace behavior handle it
            }

            // Handle Delete key for line deletion and merging
            handleDeleteKey(e) {
                const selection = window.getSelection();
                if (!selection.rangeCount) return;

                const currentLineElement = this.getCurrentLineElement();
                if (!currentLineElement) return;

                const currentContent = this.getLineRawContent(currentLineElement);
                const cursorPos = this.getCursorPositionInLine(currentLineElement);

                // Check if we should delete the entire line
                if (currentContent.trim() === '') {
                    // Empty line - delete it if there are other lines
                    const allLines = this.editor.querySelectorAll('.editor-line');
                    if (allLines.length > 1) {
                        e.preventDefault();
                        this.deleteCurrentLine(currentLineElement, 'next');
                        return;
                    }
                }

                // Check if cursor is at the end of the line (merge with next)
                if (cursorPos === currentContent.length) {
                    const nextLine = currentLineElement.nextElementSibling;

                    if (nextLine && nextLine.classList.contains('editor-line')) {
                        e.preventDefault();

                        // Get content of both lines
                        const nextContent = this.getLineRawContent(nextLine);

                        // Merge content
                        const mergedContent = currentContent + nextContent;

                        // Update current line with merged content
                        if (currentLineElement.classList.contains('editing')) {
                            currentLineElement.textContent = mergedContent;
                        } else {
                            this.makeLineEditable(currentLineElement);
                            currentLineElement.textContent = mergedContent;
                        }

                        // Position cursor at the junction point
                        this.setCursorInLineSafe(currentLineElement, currentContent.length);

                        // Remove next line
                        nextLine.remove();

                        this.updateLineIndices();
                        this.updateLineNumbersImmediate();
                    }
                }
                // If cursor is not at end, let default delete behavior handle it
            }  
          // Delete the current line and move cursor appropriately
            deleteCurrentLine(lineElement, direction = 'previous') {
                const allLines = this.editor.querySelectorAll('.editor-line');
                if (allLines.length <= 1) {
                    // Don't delete the last line, just clear it
                    lineElement.innerHTML = '';
                    lineElement.classList.add('editing');
                    const textNode = document.createTextNode('\u200B');
                    lineElement.appendChild(textNode);
                    this.setCursorInLineSafe(lineElement, 0);
                    return;
                }

                // Find target line to move cursor to
                let targetLine;
                if (direction === 'previous') {
                    targetLine = lineElement.previousElementSibling;
                    if (!targetLine) {
                        targetLine = lineElement.nextElementSibling;
                    }
                } else {
                    targetLine = lineElement.nextElementSibling;
                    if (!targetLine) {
                        targetLine = lineElement.previousElementSibling;
                    }
                }

                if (targetLine && targetLine.classList.contains('editor-line')) {
                    // Ensure target line is in edit mode
                    if (!targetLine.classList.contains('editing')) {
                        this.makeLineEditable(targetLine);
                    }

                    // Position cursor at appropriate position
                    const targetContent = targetLine.textContent || '';
                    const cursorPos = direction === 'previous' ? targetContent.length : 0;
                    this.setCursorInLineSafe(targetLine, cursorPos);

                    // Update current editing line reference
                    this.currentEditingLineElement = targetLine;

                    // Remove the line
                    lineElement.remove();

                    this.updateLineIndices();
                    this.updateLineNumbersImmediate();
                }
            }

            // Insert a new line after the current line
            insertNewLineAfter(currentLineElement, content = '') {
                const newLineDiv = document.createElement('div');
                newLineDiv.className = 'editor-line editing';

                if (content.trim() === '') {
                    // Empty line - add zero-width space for cursor visibility
                    const textNode = document.createTextNode('\u200B');
                    newLineDiv.appendChild(textNode);
                } else {
                    newLineDiv.textContent = content;
                }

                const lineIndex = parseInt(currentLineElement.dataset.lineIndex) + 1;
                newLineDiv.dataset.lineIndex = lineIndex;

                currentLineElement.parentNode.insertBefore(newLineDiv, currentLineElement.nextSibling);

                // Update line indices for subsequent lines
                this.updateLineIndices();

                this.updateLineNumbersImmediate();

                // Move cursor to new line with error handling
                if (content.trim() === '') {
                    // Position cursor in zero-width space
                    setTimeout(() => {
                        const textNode = newLineDiv.firstChild;
                        if (textNode) {
                            const range = document.createRange();
                            const selection = window.getSelection();
                            range.setStart(textNode, 0);
                            range.collapse(true);
                            selection.removeAllRanges();
                            selection.addRange(range);
                            this.editor.focus();
                        }
                    }, 0);
                } else {
                    this.setCursorInLineSafe(newLineDiv, content.length);
                }

                this.currentEditingLineElement = newLineDiv;

                // Ensure cursor remains visible after DOM changes
                setTimeout(() => {
                    this.ensureCursorVisible();
                }, 0);
            } 
           // Handle Tab key for list indentation
            handleTabKey(e) {
                const currentLineElement = this.getCurrentLineElement();
                if (!currentLineElement) return;

                const currentLineText = currentLineElement.textContent || '';
                const unorderedMatch = currentLineText.match(/^(\s*)[-*+] (.*)$/);
                const orderedMatch = currentLineText.match(/^(\s*)(\d+)\. (.*)$/);

                if (unorderedMatch || orderedMatch) {
                    e.preventDefault();

                    if (e.shiftKey) {
                        // Shift+Tab: Decrease indentation
                        this.decreaseListIndent(currentLineElement);
                    } else {
                        // Tab: Increase indentation
                        this.increaseListIndent(currentLineElement);
                    }
                }
            }

            // Increase list item indentation
            increaseListIndent(lineElement) {
                const currentText = lineElement.textContent || '';
                const cursorPos = this.getCursorPositionInLine(lineElement);

                // Add two spaces at the beginning
                lineElement.textContent = '  ' + currentText;

                // Restore cursor position
                this.setCursorInLine(lineElement, cursorPos + 2);
            }

            // Decrease list item indentation
            decreaseListIndent(lineElement) {
                const currentText = lineElement.textContent || '';
                const cursorPos = this.getCursorPositionInLine(lineElement);

                let newText = currentText;
                let adjustment = 0;

                // Remove up to two spaces from the beginning
                if (currentText.startsWith('  ')) {
                    newText = currentText.substring(2);
                    adjustment = -2;
                } else if (currentText.startsWith(' ')) {
                    newText = currentText.substring(1);
                    adjustment = -1;
                }

                if (adjustment !== 0) {
                    lineElement.textContent = newText;
                    this.setCursorInLine(lineElement, Math.max(0, cursorPos + adjustment));
                }
            }
        }   
     // ToolbarController class for managing formatting buttons
        class ToolbarController {
            constructor(editingController) {
                this.editingController = editingController;
                this.buttons = {};
                this.initializeButtons();
                this.setupEventListeners();
            }

            initializeButtons() {
                this.buttons = {
                    bold: document.getElementById('boldBtn'),
                    italic: document.getElementById('italicBtn'),
                    strikethrough: document.getElementById('strikeBtn'),
                    highlight: document.getElementById('highlightBtn'),
                    h1: document.getElementById('h1Btn'),
                    h2: document.getElementById('h2Btn'),
                    h3: document.getElementById('h3Btn'),
                    ul: document.getElementById('ulBtn'),
                    ol: document.getElementById('olBtn'),
                    hr: document.getElementById('hrBtn')
                };
            }

            setupEventListeners() {
                // Basic formatting buttons
                this.buttons.bold.addEventListener('click', () => this.toggleFormatting('bold'));
                this.buttons.italic.addEventListener('click', () => this.toggleFormatting('italic'));
                this.buttons.strikethrough.addEventListener('click', () => this.toggleFormatting('strikethrough'));
                this.buttons.highlight.addEventListener('click', () => this.toggleFormatting('highlight'));

                // Heading buttons
                this.buttons.h1.addEventListener('click', () => this.applyHeading('h1'));
                this.buttons.h2.addEventListener('click', () => this.applyHeading('h2'));
                this.buttons.h3.addEventListener('click', () => this.applyHeading('h3'));

                // List and rule buttons
                this.buttons.ul.addEventListener('click', () => this.insertList('ul'));
                this.buttons.ol.addEventListener('click', () => this.insertList('ol'));
                this.buttons.hr.addEventListener('click', () => this.insertHorizontalRule());

                // Update button states on selection change
                document.addEventListener('selectionchange', () => {
                    this.updateButtonStates();
                });

                // Update button states on editor input
                this.editingController.editor.addEventListener('input', () => {
                    setTimeout(() => this.updateButtonStates(), 10);
                });
            }

            toggleFormatting(type) {
                if (this.editingController.hasFormatting(type)) {
                    this.editingController.removeFormatting(type);
                } else {
                    this.editingController.applyFormatting(type);
                }
                this.updateButtonStates();
            }

            applyHeading(level) {
                this.editingController.applyFormatting(level);
                this.updateButtonStates();
            }           
 insertList(type) {
                const currentLine = this.editingController.getCurrentLineElement();
                if (!currentLine) return;

                // Ensure line is in edit mode
                if (!currentLine.classList.contains('editing')) {
                    this.editingController.makeLineEditable(currentLine);
                }

                const prefix = type === 'ul' ? '- ' : '1. ';

                // If line is empty, just add the prefix
                if (!currentLine.textContent.trim()) {
                    currentLine.textContent = prefix;
                    // Position cursor at the end (after the prefix)
                    this.editingController.setCursorInLine(currentLine, prefix.length);
                } else {
                    // If line has content, add prefix at the beginning
                    const currentText = currentLine.textContent;
                    currentLine.textContent = prefix + currentText;
                    // Position cursor after the prefix
                    this.editingController.setCursorInLine(currentLine, prefix.length);
                }
            }

            insertHorizontalRule() {
                this.editingController.insertMarkdownSyntax('\n---\n');
            }

            updateButtonStates() {
                if (!this.editingController.isEditing()) return;

                // Update formatting button states
                Object.keys(this.buttons).forEach(type => {
                    if (['ul', 'ol', 'hr'].includes(type)) return; // Skip list and hr buttons

                    const button = this.buttons[type];
                    const hasFormat = this.editingController.hasFormatting(type);

                    if (hasFormat) {
                        button.classList.add('active');
                    } else {
                        button.classList.remove('active');
                    }
                });
            }
        }

        // DemoManager class - No localStorage, just initialization
        class DemoManager {
            constructor(editor, editingController, renderer) {
                this.editor = editor;
                this.editingController = editingController;
                this.renderer = renderer;
            }

            // Get current content as markdown
            getCurrentContent() {
                if (this.editingController.getAllContent) {
                    return this.editingController.getAllContent();
                }
                return this.editor.textContent || '';
            }

            // Initialize editor with demo content
            loadDemoContent() {
                try {
                    // Set Quartext default content
                    const demoContent = `# Quartext
A single-pane, lightweight Markdown editor that's *seamlessly built into your browser.*

- ðŸ’­ Bugs, Feedback or Requests *(click bottom link to direct to forms)*
- ðŸ¤ Business / Collaboration: **buildsgordon@gmail.com**

---

### Why Quartext?

Most Markdown editors aren't made for quick thoughts â€” **they're too heavy, too slow, or too complex.**

**Quartext** is built for **speed and simplicity.** It's your **"thought capturer"** â€” always ready, always reliable, always there.

*(Think of it as a digital sticky note.)*

And the best part? It's **open source** and takes **under 10 seconds** to download.

---

### Supported Markdown

# Header 1
## Header 2
### Header 3

Headers are *collapsible!*

**Bold** | *Italic* | ==Highlight== | ~~Strikethrough~~

- Bullet list item
- Also known as an unordered list

1. Numbered list item
2. Also called an ordered list

---

### Features

1. **Keyboard shortcuts** â€” Ctrl+B (bold), Ctrl+I (italic), Ctrl+Shift+C (copy all)
2. **Collapsible headings**
3. **Autosave** â€” your data stays in your browser
4. **Line numbers**
5. **Light & Dark themes**

---

### âš ï¸ Known Issues & Fixes

- Sometimes rendering breaks â€” clicking the affected line and clicking off fixes it
- Collapsed header states aren't preserved after reload

---

### Links

- **GitHub Repo:** [github.com/buildsgordon/Quartext](https://github.com/buildsgordon/Quartext)
- **Feedback / Suggestions:** buildsgordon@gmail.com`;

                    this.editor.textContent = demoContent;

                    // Initialize the editor with retry logic
                    const initializeWithRetry = (attempt = 1) => {
                        try {
                            if (this.editingController && this.editingController.initializeEditor) {
                                this.editingController.initializeEditor();

                                setTimeout(() => {
                                    const lines = this.editor.querySelectorAll('.editor-line');
                                    if (lines.length === 0 && attempt < 3) {
                                        initializeWithRetry(attempt + 1);
                                    } else {
                                        this.editingController.updateLineNumbersNow();
                                        setTimeout(() => {
                                            this.editingController.forceRenderAllLines();
                                        }, 200);
                                    }
                                }, 100);
                            } else if (attempt < 3) {
                                setTimeout(() => initializeWithRetry(attempt + 1), 200);
                            }
                        } catch (initError) {
                            if (attempt < 3) {
                                setTimeout(() => initializeWithRetry(attempt + 1), 300);
                            }
                        }
                    };

                    setTimeout(() => initializeWithRetry(), 200);

                } catch (error) {
                    // Force initialization even if loading failed
                    setTimeout(() => {
                        if (this.editingController && this.editingController.initializeEditor) {
                            this.editingController.initializeEditor();
                        }
                    }, 300);
                }
            }

            // No-op methods for compatibility
            scheduleSave() {
                // Demo mode - no saving
            }

            // Export content for manual save
            exportContent() {
                return this.getCurrentContent();
            }
        }

        const editor = document.getElementById("editor");
        const lineNumbers = document.getElementById("lineNumbers");
        const status = document.getElementById("status");
        const saveBtn = document.getElementById("saveBtn");
        const themeBtn = document.getElementById("themeBtn");

        // Initialize all components with better error handling
        let markdownRenderer, editingController, toolbarController, demoManager;

        try {
            markdownRenderer = new MarkdownRenderer();
            editingController = new EditingController(editor, markdownRenderer);
            toolbarController = new ToolbarController(editingController);
            demoManager = new DemoManager(editor, editingController, markdownRenderer);

            // Set reference for demo manager in editing controller (for compatibility)
            editingController.autosaveManager = demoManager;

            // Load demo content with delay to ensure DOM is ready
            setTimeout(() => {
                demoManager.loadDemoContent();
            }, 100);

        } catch (error) {
            // Fallback initialization
            setTimeout(() => {
                try {
                    demoManager.loadDemoContent();
                } catch (e) {
                    // Silent fallback
                }
            }, 500);
        }

        // Get text content from contentEditable, preserving line breaks
        function getEditorText() {
            if (editingController && editingController.getAllContent) {
                return editingController.getAllContent();
            }
            return editor.textContent || "";
        }     
   // Compute visual line numbers accounting for collapsed content and actual line heights
        // UNIFIED SYSTEM: Uses the same logic as updateLineNumbersNow() for consistency
        function computeVisualLineNumbers(text) {
            // Delegate to the EditingController's unified system if available
            if (editingController && editingController.calculateLineNumbers) {
                return editingController.calculateLineNumbers();
            }

            // Fallback: use the same logic as updateLineNumbersNow()
            const editorLines = editor.querySelectorAll('.editor-line');
            let numbersHtml = "";
            let visibleLineCount = 0;

            for (let i = 0; i < editorLines.length; i++) {
                const line = editorLines[i];

                // Skip collapsed lines
                if (line.classList.contains('collapsed')) {
                    continue;
                }

                visibleLineCount++;

                // Check if this is a header line for spacing
                const headerElement = line.querySelector('h1, h2, h3, h4, h5, h6');

                if (headerElement) {
                    // Use EXACT same spacing logic as updateLineNumbersNow()
                    const headerTag = headerElement.tagName.toLowerCase();
                    let extraLines = 0;

                    switch (headerTag) {
                        case 'h1': extraLines = 1; break;  // H1 gets 1 extra line
                        case 'h2': extraLines = 0; break;  // H2 gets no extra lines  
                        case 'h3': extraLines = 0; break;  // H3 gets no extra lines
                        default: extraLines = 0; break;
                    }

                    // Add the main line number
                    numbersHtml += `${visibleLineCount}<br>`;

                    // Add extra spacing lines
                    for (let j = 0; j < extraLines; j++) {
                        numbersHtml += `<br>`;
                    }
                } else {
                    // Regular line, just add the number
                    numbersHtml += `${visibleLineCount}<br>`;
                }
            }

            return {
                html: numbersHtml || "1<br>",
                total: Math.max(1, visibleLineCount)
            };
        }

        // Update the line numbers column and status counters
        // NOTE: This global updateAll function is now only used for:
        // - Window resize events
        // - Manual calls from console
        // - Initial setup
        // Regular input events are handled by EditingController.updateLineNumbersNow() 
        // to prevent double rendering and improve performance
        let updateId = 0;
        function updateAll() {
            // Use smart line number system
            const text = getEditorText();
            const res = computeVisualLineNumbers(text);
            // Handle both old and new HTML structures
            const fallbackHtml = res.html || '<div class="line-number" style="top: 0px;">1</div>';
            lineNumbers.innerHTML = fallbackHtml;
            updateStatus(text, res.total);
        }

        // small debounce wrapper for resize events
        let resizeTimeout = null;
        function debouncedUpdateAll(delay = 120) {
            if (resizeTimeout) clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(updateAll, delay);
        }       
 // Update word/char/line counters
        function updateStatus(text, visualLineCount) {
            // Get clean text content for accurate counting
            const cleanText = getCleanTextForCounting(text);
            const chars = cleanText.length;
            const words = cleanText.trim() ? cleanText.trim().split(/\s+/).length : 0;
            const lines = visualLineCount != null ? visualLineCount : (cleanText.split("\n").length);
            status.textContent = `Words: ${words} | Characters: ${chars} | Lines: ${lines}`;
        }

        // Get clean text content for word/character counting (removes markdown syntax)
        function getCleanTextForCounting(text) {
            if (!text) return '';

            // Remove markdown syntax for more accurate word/character counts
            let cleanText = text
                .replace(/\*\*(.*?)\*\*/g, '$1')  // Bold
                .replace(/\*(.*?)\*/g, '$1')      // Italic
                .replace(/~~(.*?)~~/g, '$1')      // Strikethrough
                .replace(/==(.*?)==/g, '$1')      // Highlight
                .replace(/^#{1,3}\s+/gm, '')      // Headings
                .replace(/^(\s*)[-*+]\s+/gm, '$1') // Unordered lists
                .replace(/^(\s*)\d+\.\s+/gm, '$1') // Ordered lists
                .replace(/^(---|\*\*\*|___)$/gm, '') // Horizontal rules
                .replace(/^\s*$/gm, '');          // Empty lines

            return cleanText;
        }

        // Optimized input handler for rapid operations
        let inputTimeout = null;
        let lastInputTime = 0;
        let rapidInputCount = 0;

        editor.addEventListener("input", () => {
            const currentTime = Date.now();
            const timeSinceLastInput = currentTime - lastInputTime;

            // Detect rapid input (less than 50ms between inputs)
            if (timeSinceLastInput < 50) {
                rapidInputCount++;
            } else {
                rapidInputCount = 0;
            }

            lastInputTime = currentTime;

            // Demo mode - no autosave
            // The EditingController handles line number updates
        });

        // On font load, window resize or orientation change recompute
        window.addEventListener("resize", () => debouncedUpdateAll(120));
        window.addEventListener("orientationchange", () => debouncedUpdateAll(120));

        // Add scroll event listener for line number updates
        editor.addEventListener("scroll", () => {
            if (editingController && editingController.updateLineNumbersNow) {
                editingController.updateLineNumbersNow();
            }
        });

        // Add periodic line number updates every 4 seconds
        setInterval(() => {
            if (editingController && editingController.updateLineNumbersNow) {
                editingController.updateLineNumbersNow();
            }
        }, 4000);  
      // Buttons
        const copyAllBtn = document.getElementById("copyAllBtn");
        
        copyAllBtn.addEventListener("click", async () => {
            try {
                // Get the raw markdown content
                const content = demoManager ? demoManager.exportContent() : getEditorText();
                
                // Copy to clipboard using the Clipboard API
                await navigator.clipboard.writeText(content);
                
                // Show success feedback
                const originalText = copyAllBtn.textContent;
                copyAllBtn.textContent = "Copied! âœ“";
                copyAllBtn.style.background = "#4CAF50";
                copyAllBtn.style.color = "white";
                
                setTimeout(() => {
                    copyAllBtn.textContent = originalText;
                    copyAllBtn.style.background = "";
                    copyAllBtn.style.color = "";
                }, 1500);
            } catch (err) {
                // Fallback for older browsers
                try {
                    const content = demoManager ? demoManager.exportContent() : getEditorText();
                    const textarea = document.createElement("textarea");
                    textarea.value = content;
                    textarea.style.position = "fixed";
                    textarea.style.opacity = "0";
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand("copy");
                    document.body.removeChild(textarea);
                    
                    // Show success feedback
                    const originalText = copyAllBtn.textContent;
                    copyAllBtn.textContent = "Copied! âœ“";
                    copyAllBtn.style.background = "#4CAF50";
                    copyAllBtn.style.color = "white";
                    
                    setTimeout(() => {
                        copyAllBtn.textContent = originalText;
                        copyAllBtn.style.background = "";
                        copyAllBtn.style.color = "";
                    }, 1500);
                } catch (fallbackErr) {
                    // Show error feedback
                    const originalText = copyAllBtn.textContent;
                    copyAllBtn.textContent = "Failed âœ—";
                    copyAllBtn.style.background = "#f44336";
                    copyAllBtn.style.color = "white";
                    
                    setTimeout(() => {
                        copyAllBtn.textContent = originalText;
                        copyAllBtn.style.background = "";
                        copyAllBtn.style.color = "";
                    }, 1500);
                }
            }
        });

        saveBtn.addEventListener("click", () => {
            const content = demoManager ? demoManager.exportContent() : getEditorText();
            const blob = new Blob([content], { type: "text/markdown" });
            const a = document.createElement("a");
            a.href = URL.createObjectURL(blob);
            a.download = "markdown-demo-export.md";
            a.click();
        });

        themeBtn.addEventListener("click", () => {
            document.body.classList.toggle("dark");
            document.body.classList.toggle("light");
            // Recompute because colors/styles changed? not necessary but safe
            debouncedUpdateAll(60);
        });

        // Global function to force complete re-initialization
        window.forceEditorReinitialize = function () {
            if (editingController) {
                editingController.forceReinitialize();
            }
        };

        // Global function to force re-render all lines
        window.forceRenderAllLines = function () {
            if (editingController) {
                editingController.forceRenderAllLines();
            }
        };

        // Global function to test rendering (for debugging)
        window.testRendering = function () {
            const lines = editor.querySelectorAll('.editor-line');

            lines.forEach((line, i) => {
                const content = line.textContent || '';

                // Test if this line should be a list
                if (content.match(/^(\s*)[-*+] (.+)$/)) {
                    // Debug logging removed for cleaner code
                }
            });

            // Force re-render
            if (editingController) {
                editingController.forceRenderAllLines();
            }
        };

        // Demo version - no localStorage debugging needed
        window.debugStorage = function () {
            console.log('Demo mode - no localStorage used');
        };

        // Global function to manually test the rendering pipeline
        window.testPipeline = function (testContent) {
            const content = testContent || '- **bold** text\n1. *italic* item';

            // Test the markdown renderer directly
            const renderer = new MarkdownRenderer();
            const lines = content.split('\n');
            lines.forEach((line, i) => {
                const result = renderer.parseLine(line);
                // Debug logging removed for cleaner code
            });
        };

        // Global debug function
        window.debugEditor = function () {
            if (editingController) {
                editingController.debugEditorState();
            }
        };  
      // Global function to explain line number calculation
        window.explainLineNumbers = function () {
            if (editingController && editingController.calculateLineNumbers) {
                const result = editingController.calculateLineNumbers();
                // Debug logging removed for cleaner code
            } else {
                const editor = document.getElementById('editor');
                const lines = editor.querySelectorAll('.editor-line');

                let visibleCount = 0;
                let collapsedCount = 0;

                lines.forEach((line, index) => {
                    const isCollapsed = line.classList.contains('collapsed');
                    const content = line.textContent.substring(0, 30) + (line.textContent.length > 30 ? '...' : '');

                    if (isCollapsed) {
                        collapsedCount++;
                    } else {
                        visibleCount++;
                    }
                });
            }
        };

        // Global function to force line number recalculation and show debug info
        window.debugLineNumbers = function () {
            // Force both systems to recalculate
            if (editingController && editingController.updateLineNumbersNow) {
                editingController.updateLineNumbersNow();
            }

            updateAll();

            // Show current state
            const lineNumbers = document.getElementById('lineNumbers');
            const status = document.getElementById('status');

            // Explain the calculation
            window.explainLineNumbers();
        };

        // Initial render with error handling
        // Use requestAnimationFrame to ensure CSS computed values are available
        requestAnimationFrame(() => {
            try {
                updateAll();

                // Editor initialization is handled by DemoManager
            } catch (error) {
                // Fallback to basic functionality
                editor.focus();
            }
        });

        // Use MutationObserver to detect style changes on body (for theme changes, etc.)
        const mo = new MutationObserver(() => debouncedUpdateAll(80));
        mo.observe(document.documentElement, { attributes: true, attributeFilter: ["class", "style"] });

        // Add keyboard shortcuts for formatting
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key.toLowerCase()) {
                    case 'b':
                        e.preventDefault();
                        toolbarController.toggleFormatting('bold');
                        break;
                    case 'i':
                        e.preventDefault();
                        toolbarController.toggleFormatting('italic');
                        break;
                    case 'c':
                        // Ctrl+Shift+C = Copy All
                        if (e.shiftKey) {
                            e.preventDefault();
                            copyAllBtn.click();
                        }
                        // Regular Ctrl+C is handled by browser
                        break;
                    case 's':
                        e.preventDefault();
                        // Save functionality
                        saveBtn.click();
                        break;
                    case 'z':
                        e.preventDefault();
                        if (e.shiftKey) {
                            // Ctrl+Shift+Z = Redo
                            editingController.redo();
                        } else {
                            // Ctrl+Z = Undo
                            editingController.undo();
                        }
                        break;
                    case 'y':
                        e.preventDefault();
                        // Ctrl+Y = Redo (alternative)
                        editingController.redo();
                        break;
                    case 'r':
                        // Only if Ctrl+Shift+R (for debugging)
                        if (e.shiftKey) {
                            e.preventDefault();
                            window.forceEditorReinitialize();
                        }
                        break;
                }
            }
        });

    })();
</script>
</body>

</html>