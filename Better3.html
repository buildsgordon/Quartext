<!DOCTYPE html>
<html lang="en">
<!--
    Better3.html - Fixed Source Mode
    
    MAJOR FIXES IN BETTER3:
    - Source mode now works properly - no more random re-rendering
    - Clicking off a line in source mode no longer triggers formatting
    - Source mode is properly enforced across all editor interactions
    - Code blocks in source mode now use ``` syntax instead of [CODE] markers
    - Switching between modes properly converts code blocks:
      * Edit/View mode: Visual code blocks with syntax highlighting
      * Source mode: Raw ``` markdown syntax
    - Mode state is properly checked before any formatting operations
    - Blur events respect source mode and don't format lines
    - Selection changes don't trigger line switching in source mode
    
    PREVIOUS FEATURES (from Better2):
    - Code blocks, tables, and images support
    - Toggle-aware formatting buttons
    - Bold text in lists persists on reload
    - Nested formatting support
    - Selection wrapping works correctly
-->
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Markdown WYSIWYG Editor ‚Äî Better3 (Fixed Source Mode)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&family=Roboto:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-light: #EDEDED;
            --fg-light: #3B3A3A;
            --bg-dark: #1a1a1a;
            --fg-dark: #D0D0D0;  /* Slightly darker for less contrast */
            --line-num-bg-light: #f0f0f0;
            --line-num-bg-dark: #1a1a1a;
            --line-num-fg-light: rgba(59, 58, 58, 0.4);  /* Needs opacity, so rgba() is required */
            --line-num-fg-dark: rgba(208, 208, 208, 0.4);  /* Updated to match new fg-dark */
            --line-num-current-light: #3B3A3A;
            --line-num-current-dark: #D0D0D0;  /* Slightly darker for less contrast */
        }

        body.light {
            background: var(--bg-light);
            color: var(--fg-light);
        }

        body.dark {
            background: var(--bg-dark);
            color: var(--fg-dark);
        }

        html,
        body {
            height: 100vh;
            margin: 0;
            padding: 0;
            font-family: var(--editor-font, 'Roboto Mono'), monospace;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        /* Custom scrollbar styles */
        ::-webkit-scrollbar {
            width: 8px;
            transition: width 0.3s ease;
        }
        
        ::-webkit-scrollbar:hover {
            width: 12px;
        }
        
        ::-webkit-scrollbar-track {
            background: transparent;
        }
        
        ::-webkit-scrollbar-thumb {
            background: rgba(103, 103, 103, 0.3);
            border-radius: 6px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(128, 128, 128, 0.5);
        }
        
        body.dark ::-webkit-scrollbar-thumb {
            background: rgba(200, 200, 200, 0.3);
        }
        
        body.dark ::-webkit-scrollbar-thumb:hover {
            background: rgba(200, 200, 200, 0.5);
        }

        .toolbar {
            background: #eee;
            border-bottom: 1px solid #ccc;
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .formatting-buttons {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .utility-buttons {
            display: flex;
            gap: 8px;
            align-items: center;
        }  
      .separator {
            width: 1px;
            height: 24px;
            background: #ccc;
            margin: 0 8px;
        }

        body.dark .separator {
            background: #555;
        }

        button, select {
            border: 1px solid #bbb;
            background: #fff;
            border-radius: 6px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 14px;
        }
        
        #modeSelector {
            font-family: inherit;
            min-width: 140px;
        }

        .format-btn {
            padding: 4px 8px;
            font-size: 12px;
            min-width: 32px;
            transition: all 0.2s ease;
        }

        .format-btn:hover {
            background: #f0f0f0;
        }

        .format-btn.active {
            background: #007acc;
            color: #fff;
            border-color: #007acc;
        }

        body.dark .toolbar {
            background: #2a2a2a;
            border-bottom-color: #444;
        }

        body.dark button, body.dark select {
            background: #333;
            color: #ddd;
            border-color: #555;
        }

        body.dark .format-btn:hover {
            background: #444;
        }

        body.dark .format-btn.active {
            background: #007acc;
            color: #fff;
        }

        .editor-wrapper {
            display: flex;
            flex: 1;
            height: calc(100vh - 50px);
            /* toolbar height only */
            overflow: hidden;
            position: relative;
        }
        
        /* Minimap styles */
        .minimap {
            width: 120px;
            background: rgba(0, 0, 0, 0.05);
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            border-left: 1px solid #ccc;
            display: var(--minimap-display, block);
            font-size: 4px;
            line-height: 5px;
            font-family: monospace;
            padding: 8px 4px;
            padding-bottom: var(--minimap-bottom-padding, 60px);
            user-select: none;
            order: 2;
        }
        
        /* Hide minimap scrollbar but keep functionality */
        .minimap::-webkit-scrollbar {
            width: 0px;
            background: transparent;
        }
        
        body.dark .minimap {
            background: rgba(255, 255, 255, 0.03);
            border-left-color: #444;
        }
        
        .minimap-content {
            color: rgba(0, 0, 0, 0.7);
            white-space: pre-wrap;
            word-break: break-word;
            font-size: 4px;
            line-height: 5px;
            pointer-events: none;
        }
        
        .minimap-content div {
            margin: 0;
            padding: 0;
            line-height: 5px;
        }
        
        .minimap-content div.minimap-header {
            font-size: 6px;
            line-height: 7px;
            color: rgba(0, 0, 0, 1);
            margin: 3px 0 2px 0;
        }
        
        .minimap-content div.minimap-current-line {
            color: rgba(0, 0, 0, 1);
            background: rgba(0, 0, 0, 0.05);
        }
        
        .minimap-content mark {
            background-color: rgba(255, 235, 59, 0.6);
            color: inherit;
            padding: 0;
        }
        
        body.dark .minimap-content {
            color: rgba(255, 255, 255, 0.5);
        }
        
        body.dark .minimap-content div.minimap-header {
            color: #D0D0D0;  /* Match main text color for consistency */
        }
        
        body.dark .minimap-content div.minimap-current-line {
            color: #D0D0D0;
            background: rgba(255, 255, 255, 0.08);
        }
        
        body.dark .minimap-content mark {
            background-color: rgba(255, 193, 7, 0.4);
        }
        
        .minimap-viewport {
            position: fixed;
            background: rgba(80, 80, 180, 0.25);
            border: 1px solid rgba(80, 80, 180, 0.6);
            pointer-events: none;
            z-index: 10;
        }
        
        body.dark .minimap-viewport {
            background: rgba(120, 120, 220, 0.25);
            border: 1px solid rgba(120, 120, 220, 0.6);
        }       
 .line-numbers {
            width: auto;
            min-width: 50px;
            padding: 16px 8px 16px 8px;
            text-align: right;
            user-select: none;
            background: var(--line-num-bg-light);
            color: var(--line-num-fg-light);
            overflow: hidden;
            box-sizing: border-box;
            font-size: 16px;
            line-height: 1.4;
            font-family: var(--editor-font, 'Roboto Mono'), monospace;
            position: relative;
            display: var(--line-numbers-display, block);
        }

        .line-numbers .line-number {
            position: absolute;
            left: 8px;
            right: 8px;
            text-align: right;
            line-height: 1.4;
            color: var(--line-num-fg-light);
        }
        
        .line-numbers .line-number.current {
            color: var(--line-num-current-light);
            font-weight: 500;
        }

        body.dark .line-numbers {
            background: var(--line-num-bg-dark);
            color: var(--line-num-fg-dark);
        }
        
        body.dark .line-numbers .line-number {
            color: var(--line-num-fg-dark);
        }
        
        body.dark .line-numbers .line-number.current {
            color: var(--line-num-current-dark);
            font-weight: 500;
        }

        #editor {
            flex: 1;
            padding: 16px;
            padding-left: var(--editor-left-margin, 5%);
            padding-bottom: 60px;
            padding-right: var(--editor-right-margin, 5%);
            border: none;
            outline: none;
            resize: none;
            font-family: var(--editor-font, 'Roboto Mono'), monospace;
            font-size: 16px;
            line-height: 1.4;
            box-sizing: border-box;
            overflow-y: auto;
            overflow-x: hidden;
            white-space: pre-wrap;
            word-wrap: break-word;
            background: transparent;
            color: inherit;
            min-height: 100%;
            text-align: var(--editor-align, left);
            max-width: var(--editor-max-width, none);
            margin: var(--editor-margin, 0);
            order: 1;
        }
        
        /* View mode styles */
        body.view-mode #editor {
            user-select: text;
        }
        
        body.view-mode #editor[contenteditable="false"] {
            cursor: default;
        }
        
        body.view-mode .formatting-buttons {
            opacity: 0.5;
            pointer-events: none;
        }

        #editor:empty:before {
            content: attr(data-placeholder);
            color: #999;
            pointer-events: none;
        }

        body.dark #editor:empty:before {
            color: #666;
        }       
 /* Markdown formatting styles */
        #editor h1,
        #editor h2,
        #editor h3 {
            margin: 0.5em 0;
            font-weight: bold;
            line-height: 1.2;
        }

        #editor h1 {
            font-size: 2em;
        }

        #editor h2 {
            font-size: 1.5em;
        }

        #editor h3 {
            font-size: 1.2em;
        }

        #editor strong {
            font-weight: bold;
        }

        #editor em {
            font-style: italic;
        }

        #editor del {
            text-decoration: line-through;
        }

        #editor mark {
            background-color: #ffeb3b;
            color: #000;
            padding: 0 2px;
        }

        body.dark #editor mark {
            background-color: #ffc107;
            color: #000;
        }

        #editor hr {
            border: none;
            border-top: 2px solid #ccc;
            margin: 1em 0;
            width: 100%;
        }

        body.dark #editor hr {
            border-top-color: #555;
        }

        /* Editor line styles */
        .editor-line {
            min-height: 1.4em;
            line-height: 1.4;
            position: relative;
        }

        /* Code block styling - now handled inline in insertCodeBlock */   
     .editor-line.editing {
            /* Raw markdown editing mode */
            font-family: 'Roboto Mono', monospace;
        }

        .editor-line:not(.editing) {
            /* Formatted display mode */
            font-family: inherit;
        }

        /* Collapsible heading styles */
        .editor-line.heading {
            position: relative;
        }

        .collapse-arrow {
            display: inline-block;
            margin-right: 8px;
            width: 0;
            height: 0;
            border-left: 10px solid #666;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            cursor: pointer;
            transition: transform 0.2s ease;
            vertical-align: middle;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            pointer-events: auto;
        }

        .collapse-arrow.collapsed {
            transform: rotate(-90deg);
        }

        body.dark .collapse-arrow {
            border-left-color: #aaa;
        }

        .editor-line.collapsed {
            display: none;
        }

        .editor-line.heading.has-collapsed-content {
            margin-bottom: 0.2em;
            border-left: 3px solid #007acc;
            padding-left: 8px;
            background-color: rgba(0, 122, 204, 0.05);
        }

        body.dark .editor-line.heading.has-collapsed-content {
            border-left-color: #4fc3f7;
            background-color: rgba(79, 195, 247, 0.05);
        } 
       /* Adjust line numbers for collapse arrows */
        .line-numbers {
            width: auto;
            min-width: 50px;
            /* Auto width to fit content */
            padding: 16px 12px 16px 8px;
            /* Reduced right padding */
        }

        .main-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .statusbar {
            position: fixed;
            bottom: 8px;
            right: 8px;
            background: rgba(0, 0, 0, 0.05);
            padding: 6px 12px;
            border-radius: 6px;
            display: var(--statusbar-display, flex);
            align-items: center;
            gap: 12px;
            font-size: 12px;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        body.dark .statusbar {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.1);
        }
        
        .statusbar #status {
            margin: 0;
        }
        
        .statusbar #autosave {
            color: #4CAF50;
            font-weight: 500;
        }

        /* Hidden mirror to measure wrapped lines */
        #mirror {
            position: absolute;
            visibility: hidden;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
            top: -9999px;
            left: -9999px;
            box-sizing: border-box;
        }
        
        /* Settings panel styles */
        .settings-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .settings-overlay.active {
            display: flex;
        }
        
        .settings-panel {
            background: white;
            border-radius: 8px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        
        body.dark .settings-panel {
            background: #2a2a2a;
            color: #ddd;
        }
        
        .settings-panel h2 {
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 24px;
        }
        
        .settings-group {
            margin-bottom: 20px;
        }
        
        .settings-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .settings-group select,
        .settings-group input[type="number"],
        .settings-group input[type="range"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
            background: white;
            color: inherit;
        }
        
        .settings-group input[type="range"] {
            padding: 0;
            height: 32px;
            cursor: pointer;
        }
        
        body.dark .settings-group select,
        body.dark .settings-group input[type="number"],
        body.dark .settings-group input[type="range"] {
            background: #333;
            border-color: #555;
            color: #ddd;
        }
        
        .settings-group .toggle-switch {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .settings-group .toggle-switch input[type="checkbox"] {
            width: 48px;
            height: 24px;
            appearance: none;
            background: #ccc;
            border-radius: 12px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .settings-group .toggle-switch input[type="checkbox"]:checked {
            background: #007acc;
        }
        
        .settings-group .toggle-switch input[type="checkbox"]::before {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            top: 2px;
            left: 2px;
            transition: left 0.3s;
        }
        
        .settings-group .toggle-switch input[type="checkbox"]:checked::before {
            left: 26px;
        }
        
        .settings-close {
            margin-top: 20px;
            width: 100%;
            padding: 10px;
            background: #007acc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        
        .settings-close:hover {
            background: #005a9e;
        }
    </style>
</head>

<body class="light">
    <div class="main-container">
        <div class="toolbar">
            <div class="formatting-buttons">
                <button id="boldBtn" class="format-btn" title="Bold (Ctrl+B)"><strong>B</strong></button>
                <button id="italicBtn" class="format-btn" title="Italic (Ctrl+I)"><em>I</em></button>
                <button id="strikeBtn" class="format-btn" title="Strikethrough">SÃ∂</button>
                <button id="highlightBtn" class="format-btn" title="Highlight">H</button>
                <div class="separator"></div>
                <button id="h1Btn" class="format-btn" title="Heading 1">H1</button>
                <button id="h2Btn" class="format-btn" title="Heading 2">H2</button>
                <button id="h3Btn" class="format-btn" title="Heading 3">H3</button>
                <div class="separator"></div>
                <button id="ulBtn" class="format-btn" title="Unordered List">‚Ä¢ List</button>
                <button id="olBtn" class="format-btn" title="Ordered List">1. List</button>
                <button id="hrBtn" class="format-btn" title="Horizontal Rule">‚Äî</button>
                <div class="separator"></div>
                <button id="codeBtn" class="format-btn" title="Code Block">&lt;/&gt;</button>
                <button id="imageBtn" class="format-btn" title="Insert Image">üñºÔ∏è</button>
                <button id="tableBtn" class="format-btn" title="Insert Table">‚äû</button>
            </div>
            <div class="utility-buttons">
                <select id="modeSelector" title="Editor Mode">
                    <option value="edit">‚úè Edit Mode</option>
                    <option value="view">üëÅ View Mode</option>
                    <option value="source">‚å® Source Mode</option>
                </select>
                <button id="settingsBtn" title="Settings"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" style="vertical-align: middle;"><circle cx="12" cy="12" r="3" stroke="currentColor" stroke-width="1.5"/><path d="M3.66122 10.6392C4.13377 10.9361 4.43782 11.4419 4.43782 11.9999C4.43781 12.558 4.13376 13.0638 3.66122 13.3607C3.33966 13.5627 3.13248 13.7242 2.98508 13.9163C2.66217 14.3372 2.51966 14.869 2.5889 15.3949C2.64082 15.7893 2.87379 16.1928 3.33973 16.9999C3.80568 17.8069 4.03865 18.2104 4.35426 18.4526C4.77508 18.7755 5.30694 18.918 5.83284 18.8488C6.07287 18.8172 6.31628 18.7185 6.65196 18.5411C7.14544 18.2803 7.73558 18.2699 8.21895 18.549C8.70227 18.8281 8.98827 19.3443 9.00912 19.902C9.02332 20.2815 9.05958 20.5417 9.15224 20.7654C9.35523 21.2554 9.74458 21.6448 10.2346 21.8478C10.6022 22 11.0681 22 12 22C12.9319 22 13.3978 22 13.7654 21.8478C14.2554 21.6448 14.6448 21.2554 14.8478 20.7654C14.9404 20.5417 14.9767 20.2815 14.9909 19.9021C15.0117 19.3443 15.2977 18.8281 15.7811 18.549C16.2644 18.27 16.8545 18.2804 17.3479 18.5412C17.6837 18.7186 17.9271 18.8173 18.1671 18.8489C18.693 18.9182 19.2249 18.7756 19.6457 18.4527C19.9613 18.2106 20.1943 17.807 20.6603 17C20.8677 16.6407 21.029 16.3614 21.1486 16.1272M20.3387 13.3608C19.8662 13.0639 19.5622 12.5581 19.5621 12.0001C19.5621 11.442 19.8662 10.9361 20.3387 10.6392C20.6603 10.4372 20.8674 10.2757 21.0148 10.0836C21.3377 9.66278 21.4802 9.13092 21.411 8.60502C21.3591 8.2106 21.1261 7.80708 20.6601 7.00005C20.1942 6.19301 19.9612 5.7895 19.6456 5.54732C19.2248 5.22441 18.6929 5.0819 18.167 5.15113C17.927 5.18274 17.6836 5.2814 17.3479 5.45883C16.8544 5.71964 16.2643 5.73004 15.781 5.45096C15.2977 5.1719 15.0117 4.6557 14.9909 4.09803C14.9767 3.71852 14.9404 3.45835 14.8478 3.23463C14.6448 2.74458 14.2554 2.35523 13.7654 2.15224C13.3978 2 12.9319 2 12 2C11.0681 2 10.6022 2 10.2346 2.15224C9.74458 2.35523 9.35523 2.74458 9.15224 3.23463C9.05958 3.45833 9.02332 3.71848 9.00912 4.09794C8.98826 4.65566 8.70225 5.17191 8.21891 5.45096C7.73557 5.73002 7.14548 5.71959 6.65205 5.4588C6.31633 5.28136 6.0729 5.18269 5.83285 5.15108C5.30695 5.08185 4.77509 5.22436 4.35427 5.54727C4.03866 5.78945 3.80569 6.19297 3.33974 7C3.13231 7.35929 2.97105 7.63859 2.85138 7.87273" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg></button>
                <button id="saveBtn"><svg width="18" height="18" viewBox="0 0 488.446 488.446" fill="currentColor" style="vertical-align: middle;"><path d="M153.029,90.223h182.404c5.427,0,9.873-4.43,9.873-9.869V0H143.137v80.354C143.137,85.793,147.571,90.223,153.029,90.223z"/><path d="M480.817,122.864L377.88,19.494v60.859c0,23.404-19.043,42.447-42.447,42.447H153.029c-23.409,0-42.447-19.043-42.447-42.447V0H44.823C20.068,0,0.002,20.07,0.002,44.808v398.831c0,24.736,20.066,44.808,44.821,44.808h398.813c24.74,0,44.808-20.068,44.808-44.808V141.325C488.444,134.392,485.698,127.758,480.817,122.864z M412.461,385.666c0,14.434-11.703,26.154-26.168,26.154H102.137c-14.451,0-26.153-11.722-26.153-26.154V249.303c0-14.43,11.702-26.148,26.153-26.148h284.156c14.465,0,26.168,11.72,26.168,26.148V385.666z"/></svg> Save</button>
            </div>
        </div> 
       <div class="editor-wrapper">
            <div id="lineNumbers" class="line-numbers" aria-hidden="true"></div>
            <div id="editor" contenteditable="true" placeholder="Start typing..." spellcheck="false"
                data-placeholder="Start typing..."></div>
            <div id="minimap" class="minimap">
                <div class="minimap-content" id="minimapContent"></div>
                <div class="minimap-viewport" id="minimapViewport"></div>
            </div>
        </div>

        <div class="statusbar">
            <span id="status">Words: 0 | Characters: 0 | Lines: 0</span>
            <span id="autosave"></span>
        </div>
    </div>
    
    <!-- Settings Panel -->
    <div class="settings-overlay" id="settingsOverlay">
        <div class="settings-panel">
            <h2>‚öôÔ∏è Editor Settings</h2>
            
            <div class="settings-group">
                <label>Theme</label>
                <div class="toggle-switch">
                    <span>Light</span>
                    <input type="checkbox" id="settingTheme">
                    <span>Dark</span>
                </div>
            </div>
            
            <div class="settings-group">
                <label for="settingFont">Font Family</label>
                <select id="settingFont">
                    <option value="'Roboto Mono'">Roboto Mono (Default)</option>
                    <option value="'Inter'">Inter</option>
                    <option value="'Roboto'">Roboto</option>
                    <option value="'Ubuntu Mono'">Ubuntu Mono</option>
                    <option value="'Open Sans'">Open Sans</option>
                </select>
            </div>
            
            <div class="settings-group">
                <label>Text Alignment</label>
                <select id="settingAlign">
                    <option value="left">Left</option>
                    <option value="center">Center</option>
                </select>
            </div>
            
            <div class="settings-group">
                <label for="settingLeftMargin">Left Margin: <span id="leftMarginValue">5%</span></label>
                <input type="range" id="settingLeftMargin" min="1" max="30" step="1" value="5">
            </div>
            
            <div class="settings-group">
                <label for="settingRightMargin">Right Margin: <span id="rightMarginValue">5%</span></label>
                <input type="range" id="settingRightMargin" min="1" max="30" step="1" value="5">
            </div>
            
            <div class="settings-group">
                <label>Show Line Numbers</label>
                <div class="toggle-switch">
                    <span>Hide</span>
                    <input type="checkbox" id="settingLineNumbers" checked>
                    <span>Show</span>
                </div>
            </div>
            
            <div class="settings-group">
                <label>Show Minimap</label>
                <div class="toggle-switch">
                    <span>Hide</span>
                    <input type="checkbox" id="settingMinimap" checked>
                    <span>Show</span>
                </div>
            </div>
            
            <div class="settings-group">
                <label>Show Status Bar</label>
                <div class="toggle-switch">
                    <span>Hide</span>
                    <input type="checkbox" id="settingStatusBar" checked>
                    <span>Show</span>
                </div>
            </div>
            
            <button class="settings-close" id="settingsClose">Close</button>
        </div>
    </div>
</body>

<!-- Mirror element removed - using smart auto-measuring line numbers instead -->

<script>
    (() => {
        const STORAGE_KEY = "marktext_autosave";

        // MarkdownRenderer class for parsing and rendering markdown
        class MarkdownRenderer {
            constructor() {
                this.patterns = {
                    bold: /\*\*(.*?)\*\*/g,
                    italic: /\*(.*?)\*/g,
                    strikethrough: /~~(.*?)~~/g,
                    highlight: /==(.*?)==/g,
                    heading1: /^# (.+)$/,
                    heading2: /^## (.+)$/,
                    heading3: /^### (.+)$/,
                    unorderedList: /^(\s*)[-*+] (.+)$/,
                    orderedList: /^(\s*)(\d+)\. (.+)$/,
                    horizontalRule: /^(---|\*\*\*|___)$/,
                    codeBlockMarker: /^```(.*)$/,
                    image: /!\[([^\]]*)\]\(([^)]+)\)/g
                };
            }

            // NEW: Parse inline markdown with proper nesting support
            parseInlineFormatting(text) {
                let html = this.escapeHtml(text);
                
                // Process images first (before other formatting)
                html = html.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1" style="max-width: 100%; height: auto; display: block; margin: 8px 0;" />');
                
                // Process links (but not images which start with !)
                html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" class="markdown-link" style="color: #007acc; text-decoration: underline; cursor: pointer;" title="Ctrl+Click to open">$1</a>');
                
                // Process bold first (** before *) to handle nested formatting correctly
                // This ensures **text** is processed before *text*
                html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
                
                // Then process italic, but avoid matching already processed bold markers
                // Use negative lookbehind/lookahead to avoid matching * that's part of **
                html = html.replace(/(?<!\*)\*(?!\*)(.+?)(?<!\*)\*(?!\*)/g, '<em>$1</em>');
                
                // Process other formatting
                html = html.replace(/~~(.+?)~~/g, '<del>$1</del>');
                html = html.replace(/==(.+?)==/g, '<mark>$1</mark>');
                
                return html;
            }

            // Convert markdown text to HTML elements with performance optimization
            parseMarkdown(text) {
                if (!text) return document.createTextNode('');

                // Use DocumentFragment for efficient DOM manipulation
                const fragment = document.createDocumentFragment();
                const lines = text.split('\n');

                // Batch DOM operations for better performance
                const elements = [];
                lines.forEach((line, index) => {
                    const lineElement = this.parseLine(line);
                    elements.push(lineElement);

                    // Add line break except for last line
                    if (index < lines.length - 1) {
                        elements.push(document.createElement('br'));
                    }
                });

                // Append all elements at once
                elements.forEach(el => fragment.appendChild(el));

                return fragment;
            }     
       // Parse a single line of markdown
            parseLine(line) {
                if (!line.trim()) {
                    const div = document.createElement('div');
                    div.style.display = 'inline';
                    div.appendChild(document.createTextNode('\u00A0')); // Non-breaking space for empty lines
                    return div;
                }

                // Check for special markers: tables and code blocks
                if (line.startsWith('[TABLE]') && line.endsWith('[/TABLE]')) {
                    const tableHTML = line.substring(7, line.length - 8);
                    const div = document.createElement('div');
                    div.innerHTML = tableHTML;
                    return div;
                }

                if (line.startsWith('[CODE]') && line.endsWith('[/CODE]')) {
                    // Reconstruct full code block structure (unescape newlines)
                    const escapedContent = line.substring(6, line.length - 7);
                    const codeContent = escapedContent.replace(/<<<NEWLINE>>>/g, '\n');
                    
                    const isDark = document.body.classList.contains('dark');
                    const container = document.createElement('div');
                    container.style.display = 'inline-block';
                    container.style.width = '100%';
                    
                    const codeContainer = document.createElement('div');
                    codeContainer.className = 'code-block-container';
                    codeContainer.style.cssText = `background: ${isDark ? '#2a2a2a' : '#f5f5f5'}; border-left: 3px solid ${isDark ? '#4fc3f7' : '#007acc'}; border-radius: 4px; margin: 8px 0; overflow: hidden;`;
                    
                    const codeHeader = document.createElement('div');
                    codeHeader.className = 'code-block-header';
                    codeHeader.style.cssText = `padding: 4px 12px; background: ${isDark ? '#1f1f1f' : '#e8e8e8'}; font-family: monospace; font-size: 12px; color: ${isDark ? '#888' : '#666'}; border-bottom: 1px solid ${isDark ? '#444' : '#ddd'};`;
                    codeHeader.textContent = 'code';
                    
                    const codeArea = document.createElement('pre');
                    codeArea.contentEditable = 'true';
                    codeArea.className = 'code-block-content';
                    codeArea.style.cssText = `margin: 0; padding: 12px; font-family: monospace; white-space: pre; overflow-x: auto; outline: none; min-height: 60px; background: ${isDark ? '#2a2a2a' : '#f5f5f5'}; color: ${isDark ? '#d0d0d0' : '#3b3a3a'};`;
                    codeArea.textContent = codeContent;
                    
                    codeContainer.appendChild(codeHeader);
                    codeContainer.appendChild(codeArea);
                    container.appendChild(codeContainer);
                    
                    return container;
                }

                // Check for headings first
                if (this.patterns.heading1.test(line)) {
                    const h1 = document.createElement('h1');
                    const match = line.match(this.patterns.heading1);
                    h1.textContent = match[1];
                    return h1;
                }

                if (this.patterns.heading2.test(line)) {
                    const h2 = document.createElement('h2');
                    const match = line.match(this.patterns.heading2);
                    h2.textContent = match[1];
                    return h2;
                }

                if (this.patterns.heading3.test(line)) {
                    const h3 = document.createElement('h3');
                    const match = line.match(this.patterns.heading3);
                    h3.textContent = match[1];
                    return h3;
                }

                // Check for unordered list
                if (this.patterns.unorderedList.test(line)) {
                    const li = document.createElement('li');
                    const match = line.match(this.patterns.unorderedList);
                    const indent = match[1].length;

                    // Process the list content for inline formatting (bold, italic, etc.)
                    const content = match[2];
                    const html = this.parseInlineFormatting(content);

                    li.innerHTML = html;
                    li.style.marginLeft = `${indent * 20 + 10}px`; // Add 10px to move bullets right
                    li.style.listStyleType = 'disc';
                    li.style.display = 'list-item';
                    return li;
                }     
           // Check for ordered list
                if (this.patterns.orderedList.test(line)) {
                    const div = document.createElement('div');
                    const match = line.match(this.patterns.orderedList);
                    const indent = match[1].length;
                    const number = match[2];
                    const content = match[3];

                    // Create a div that looks like a numbered list item
                    div.style.display = 'flex';
                    div.style.marginLeft = `${indent * 20}px`;

                    // Create number span
                    const numberSpan = document.createElement('span');
                    numberSpan.textContent = number + '. ';
                    numberSpan.style.minWidth = '2em';
                    numberSpan.style.fontWeight = 'normal';

                    // Create content span with inline formatting support
                    const contentSpan = document.createElement('span');

                    // Process the list content for inline formatting (bold, italic, etc.)
                    const html = this.parseInlineFormatting(content);

                    contentSpan.innerHTML = html;

                    div.appendChild(numberSpan);
                    div.appendChild(contentSpan);
                    return div;
                }

                // Check for horizontal rule
                if (this.patterns.horizontalRule.test(line)) {
                    const hr = document.createElement('hr');
                    return hr;
                }

                // Regular line with inline formatting
                const div = document.createElement('div');
                div.style.display = 'inline';

                const html = this.parseInlineFormatting(line);

                div.innerHTML = html;
                return div;
            }   
         // Extract markdown from formatted DOM with error handling
            extractMarkdown(element) {
                if (!element) return '';

                try {
                    // Handle single line elements
                    if (element.classList && element.classList.contains('editor-line')) {
                        if (element.classList.contains('editing')) {
                            return element.textContent || '';
                        }
                        return this.extractLineMarkdown(element);
                    }

                    // Handle full editor content
                    const lines = element.querySelectorAll('.editor-line');
                    if (lines.length > 0) {
                        const content = [];
                        lines.forEach(line => {
                            if (line.classList.contains('editing')) {
                                content.push(line.textContent || '');
                            } else {
                                content.push(this.extractLineMarkdown(line));
                            }
                        });
                        return content.join('\n');
                    }

                    // Fallback to text content
                    return element.textContent || '';
                } catch (error) {
                    return element.textContent || '';
                }
            }

            // Extract markdown from a single line element
            extractLineMarkdown(lineElement) {
                const firstChild = lineElement.firstChild;
                if (!firstChild) return '';

                // Handle different element types
                switch (firstChild.tagName?.toLowerCase()) {
                    case 'h1':
                        return '# ' + firstChild.textContent;
                    case 'h2':
                        return '## ' + firstChild.textContent;
                    case 'h3':
                        return '### ' + firstChild.textContent;
                    case 'li':
                        const indent = parseInt(firstChild.style.marginLeft) / 20 || 0;
                        const indentStr = ' '.repeat(indent);
                        // Extract inline markdown from the list item content
                        const listContent = this.extractInlineMarkdown(firstChild);
                        if (firstChild.style.listStyleType === 'decimal') {
                            return indentStr + '1. ' + listContent;
                        } else {
                            return indentStr + '- ' + listContent;
                        }
                    case 'div':
                        // Check if this is an ordered list div (has flex display and number span)
                        if (firstChild.style.display === 'flex' && firstChild.children.length === 2) {
                            const numberSpan = firstChild.children[0];
                            const contentSpan = firstChild.children[1];
                            if (numberSpan && contentSpan) {
                                const indent = parseInt(firstChild.style.marginLeft) / 20 || 0;
                                const indentStr = ' '.repeat(indent);
                                // Extract inline markdown from the content span
                                const listContent = this.extractInlineMarkdown(contentSpan);
                                return indentStr + numberSpan.textContent + listContent;
                            }
                        }
                        // Fall through to default for regular divs
                        return this.extractInlineMarkdown(lineElement);
                    case 'hr':
                        return '---';
                    default:
                        // Handle inline formatting
                        return this.extractInlineMarkdown(lineElement);
                }
            } 
           // FIX: Enhanced extractInlineMarkdown to properly convert <strong> back to **text** with nested support
            extractInlineMarkdown(element) {
                let markdown = '';

                for (let node of element.childNodes) {
                    if (node.nodeType === Node.TEXT_NODE) {
                        markdown += node.textContent;
                    } else if (node.nodeType === Node.ELEMENT_NODE) {
                        switch (node.tagName.toLowerCase()) {
                            case 'strong':
                                // Recursively extract nested content to handle nested formatting
                                markdown += '**' + this.extractInlineMarkdown(node) + '**';
                                break;
                            case 'em':
                                // Recursively extract nested content to handle nested formatting
                                markdown += '*' + this.extractInlineMarkdown(node) + '*';
                                break;
                            case 'del':
                                markdown += '~~' + this.extractInlineMarkdown(node) + '~~';
                                break;
                            case 'mark':
                                markdown += '==' + this.extractInlineMarkdown(node) + '==';
                                break;
                            case 'img':
                                // Convert image back to markdown syntax
                                const alt = node.getAttribute('alt') || '';
                                const src = node.getAttribute('src') || '';
                                markdown += `![${alt}](${src})`;
                                break;
                            case 'a':
                                // Convert link back to markdown syntax
                                const linkText = node.textContent || '';
                                const href = node.getAttribute('href') || '';
                                markdown += `[${linkText}](${href})`;
                                break;
                            case 'br':
                                markdown += '\n';
                                break;
                            default:
                                // For unknown elements, recursively extract their content
                                markdown += this.extractInlineMarkdown(node);
                        }
                    }
                }

                return markdown;
            }

            // Check if element is being actively edited
            isActivelyEditing(element) {
                const selection = window.getSelection();
                if (!selection.rangeCount) return false;

                const range = selection.getRangeAt(0);
                return element.contains(range.commonAncestorContainer);
            }

            // Escape HTML characters
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        }     
   // EditingController class for managing line-based editing (Obsidian-style)
        class EditingController {
            constructor(editor, renderer) {
                this.editor = editor;
                this.renderer = renderer;
                this.currentEditingLineElement = null;
                this.isInitialized = false;
                this.lineNumberUpdateTimeout = null;
                this.lastLineNumberUpdate = 0;
                this.isRapidOperation = false;
                this.rapidOperationTimeout = null;
                this.isSelecting = false; // Track if user is actively selecting text

                // Undo/Redo system
                this.history = [];
                this.historyIndex = -1;
                this.maxHistorySize = 50;
                this.lastSavedState = '';
                this.lastWordCount = 0; // FIX: Track word count for improved undo system
                this.delayedFormatTimeout = null; // FIX: Track delayed formatting timeout

                this.setupEventListeners();
            }

            setupEventListeners() {
                // Simplified - no complex selection handling
                
                // Handle input events for real-time updates
                this.editor.addEventListener('input', (e) => {
                    this.handleInput(e);
                    this.ensureMinimumStructure();
                    this.ensureCursorVisible();

                    // Smart line number update with debouncing
                    this.scheduleLineNumberUpdate();
                });

                // Smart line number system: observe DOM changes for auto-measuring
                // Only watch for structural changes, not text content changes
                const observer = new MutationObserver((mutations) => {
                    let shouldUpdate = false;

                    for (const mutation of mutations) {
                        // Only update for structural changes (adding/removing lines)
                        if (mutation.type === 'childList' &&
                            (mutation.addedNodes.length > 0 || mutation.removedNodes.length > 0)) {
                            // Check if editor-line elements were added/removed
                            const hasLineChanges = Array.from(mutation.addedNodes).some(node =>
                                node.nodeType === Node.ELEMENT_NODE && node.classList?.contains('editor-line')
                            ) || Array.from(mutation.removedNodes).some(node =>
                                node.nodeType === Node.ELEMENT_NODE && node.classList?.contains('editor-line')
                            );

                            if (hasLineChanges) {
                                shouldUpdate = true;
                                break;
                            }
                        }
                    }

                    if (shouldUpdate) {
                        this.scheduleLineNumberUpdate();
                    }
                });
                observer.observe(this.editor, {
                    childList: true,
                    subtree: false // Only watch direct children, not deep changes
                });    
            // Handle selection changes to switch editing lines
                this.selectionChangeTimeout = null;
                document.addEventListener('selectionchange', () => {
                    // Debounce selection changes to prevent flickering
                    if (this.selectionChangeTimeout) {
                        clearTimeout(this.selectionChangeTimeout);
                    }
                    this.selectionChangeTimeout = setTimeout(() => {
                        this.handleSelectionChange();
                    }, 50);
                });

                // Handle keydown events (merged for efficiency)
                this.editor.addEventListener('keydown', (e) => {
                    // Intercept Ctrl+A + Delete/Backspace combinations
                    if ((e.key === 'Delete' || e.key === 'Backspace') && this.isSelectAllActive()) {
                        e.preventDefault();
                        this.handleSelectAllDelete();
                        return;
                    }

                    // Handle specific keys
                    if (e.key === 'Enter') {
                        this.handleEnterKey(e);
                    } else if (e.key === 'Tab') {
                        this.handleTabKey(e);
                    } else if (e.key === 'Backspace') {
                        this.handleBackspaceKey(e);
                        // Smart line number update after deletion
                        setTimeout(() => this.scheduleLineNumberUpdate(), 50);
                    } else if (e.key === 'Delete') {
                        this.handleDeleteKey(e);
                        // Smart line number update after deletion
                        setTimeout(() => this.scheduleLineNumberUpdate(), 50);
                    } else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                        // Handle arrow keys to prevent cursor jumping
                        setTimeout(() => this.handleSelectionChange(), 0);
                    }
                });

                // Handle blur to format all lines (but not in source mode)
                this.editor.addEventListener('blur', () => {
                    if (!document.body.classList.contains('source-mode')) {
                        this.formatAllLines();
                    }
                });

                // Handle focus to start editing
                this.editor.addEventListener('focus', () => {
                    if (!this.isInitialized) {
                        this.initializeEditor();
                    }
                    setTimeout(() => this.handleSelectionChange(), 0);
                });

                // Handle click events to switch lines
                this.editor.addEventListener('click', (e) => {
                    // Don't handle clicks in view mode
                    if (document.body.classList.contains('view-mode')) {
                        return;
                    }
                    
                    // Don't handle selection change if clicking on collapse arrow or its parent
                    if (e.target.classList.contains('collapse-arrow') ||
                        e.target.closest('.collapse-arrow')) {
                        return;
                    }
                    setTimeout(() => this.handleSelectionChange(), 0);
                });

                // Handle paste events to maintain structure
                this.editor.addEventListener('paste', (e) => {
                    // Check if we're pasting inside a code block or table cell
                    const target = e.target;
                    const isInCodeBlock = target.closest('.code-block-content');
                    const isInTableCell = target.closest('td, th');
                    
                    // Allow normal paste behavior in code blocks and table cells
                    if (isInCodeBlock || isInTableCell) {
                        return; // Let the browser handle it normally
                    }
                    
                    e.preventDefault();

                    // Get pasted text
                    const pastedText = (e.clipboardData || window.clipboardData).getData('text');

                    if (pastedText) {
                        // FIX: Insert pasted content at cursor position instead of replacing everything
                        this.insertPastedContentAtCursor(pastedText);
                    }
                });

                // Handle Ctrl+Click on links
                this.editor.addEventListener('click', (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.target.classList.contains('markdown-link')) {
                        e.preventDefault();
                        const url = e.target.getAttribute('href');
                        if (url) {
                            window.open(url, '_blank');
                        }
                    }
                });
            }    
        // Clean pasted content to prevent extra lines
            cleanPastedContent(content) {
                if (!content) return '';

                // Remove excessive newlines (more than 2 consecutive)
                let cleaned = content.replace(/\n{3,}/g, '\n\n');

                // Remove trailing whitespace from lines
                cleaned = cleaned.split('\n').map(line => line.trimEnd()).join('\n');

                // Remove leading/trailing empty lines
                cleaned = cleaned.trim();

                return cleaned;
            }

            // FIX: Insert pasted content at cursor position instead of replacing everything
            insertPastedContentAtCursor(pastedText) {
                const currentLine = this.getCurrentLineElement();
                if (!currentLine) return;

                // Clean the pasted content
                const cleanedContent = this.cleanPastedContent(pastedText);
                if (!cleanedContent) return;

                // Ensure current line is in edit mode
                if (!currentLine.classList.contains('editing')) {
                    this.makeLineEditable(currentLine);
                }

                // Get current cursor position
                const selection = window.getSelection();
                if (!selection.rangeCount) return;

                const range = selection.getRangeAt(0);
                
                // Split pasted content into lines
                const pastedLines = cleanedContent.split('\n');
                
                if (pastedLines.length === 1) {
                    // Single line paste - just insert at cursor
                    const textNode = document.createTextNode(pastedLines[0]);
                    range.deleteContents();
                    range.insertNode(textNode);
                    
                    // Position cursor after inserted text
                    range.setStartAfter(textNode);
                    range.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(range);
                } else {
                    // Multi-line paste - more complex handling
                    this.handleMultiLinePaste(currentLine, pastedLines, range);
                }

                // Update line numbers and trigger autosave
                setTimeout(() => {
                    this.updateLineNumbers();
                    if (this.autosaveManager) {
                        this.autosaveManager.scheduleSave();
                    }
                }, 50);
            }

            // Handle multi-line paste by splitting current line and inserting new lines
            handleMultiLinePaste(currentLine, pastedLines, range) {
                // Get text before and after cursor
                const lineText = currentLine.textContent || '';
                const cursorPos = this.getCursorPositionInLine(currentLine);
                const textBefore = lineText.substring(0, cursorPos);
                const textAfter = lineText.substring(cursorPos);

                // Update current line with first part + first pasted line
                currentLine.textContent = textBefore + pastedLines[0];

                let lastInsertedLine = currentLine;

                // Insert middle lines (if any)
                for (let i = 1; i < pastedLines.length - 1; i++) {
                    const newLine = document.createElement('div');
                    newLine.className = 'editor-line editing';
                    newLine.textContent = pastedLines[i];
                    
                    lastInsertedLine.parentNode.insertBefore(newLine, lastInsertedLine.nextSibling);
                    lastInsertedLine = newLine;
                }

                // Insert final line with remaining text
                if (pastedLines.length > 1) {
                    const finalLine = document.createElement('div');
                    finalLine.className = 'editor-line editing';
                    finalLine.textContent = pastedLines[pastedLines.length - 1] + textAfter;
                    
                    lastInsertedLine.parentNode.insertBefore(finalLine, lastInsertedLine.nextSibling);
                    
                    // Position cursor at end of pasted content in final line
                    const cursorPosition = pastedLines[pastedLines.length - 1].length;
                    setTimeout(() => {
                        this.setCursorInLineSafe(finalLine, cursorPosition);
                        this.currentEditingLineElement = finalLine;
                    }, 10);
                }

                // Update line indices
                this.updateLineIndices();
            }

            // Handle pasted content by converting it to proper line structure (LEGACY - kept for compatibility)
            handlePastedContent(pastedText) {
                // Clean the pasted content first
                const cleanedContent = this.cleanPastedContent(pastedText);

                // Clear editor completely
                this.editor.innerHTML = '';

                // Reset initialization state
                this.isInitialized = false;
                this.currentEditingLineElement = null;

                // Directly render the formatted content
                this.renderFormattedContent(cleanedContent);

                // Mark as initialized
                this.isInitialized = true;

                // Update line numbers (self-contained, no double rendering)
                const updateLineNumbers = () => {
                    this.updateLineNumbersNow();
                };

                // Immediate update
                updateLineNumbers();

                // Delayed updates to ensure everything is ready
                setTimeout(updateLineNumbers, 50);
                setTimeout(updateLineNumbers, 150);
                setTimeout(updateLineNumbers, 300);

                setTimeout(() => {
                    // Trigger autosave after paste (treat as edit operation)
                    if (this.autosaveManager) {
                        this.autosaveManager.scheduleSave();
                    }

                    // Trigger input event to ensure all handlers are called
                    const inputEvent = new Event('input', { bubbles: true });
                    this.editor.dispatchEvent(inputEvent);
                }, 100);
            }     
       // Reinitialize editor with new content
            reinitializeWithContent(content) {
                this.isInitialized = false;
                this.editor.innerHTML = '';
                this.editor.textContent = content;

                setTimeout(() => {
                    this.initializeEditor();
                    this.updateLineNumbers();
                }, 0);
            }

            // Initialize editor with formatted content
            initializeEditor() {
                if (this.isInitialized) return;

                const content = this.editor.textContent || '';

                try {
                    if (content.trim()) {
                        this.renderFormattedContent(content);

                        // Force immediate formatting of all lines after rendering
                        setTimeout(() => {
                            const lines = this.editor.querySelectorAll('.editor-line');
                            lines.forEach(line => {
                                if (!line.classList.contains('editing')) {
                                    // Line should be formatted, ensure it's properly rendered
                                    const rawContent = this.getLineRawContent(line);
                                    if (rawContent.trim()) {
                                        const formattedElement = this.renderer.parseLine(rawContent);
                                        line.innerHTML = '';
                                        if (formattedElement.tagName === 'DIV') {
                                            line.innerHTML = formattedElement.innerHTML;
                                        } else {
                                            line.appendChild(formattedElement);
                                        }
                                    }
                                }
                            });
                            this.scheduleLineNumberUpdate();
                        }, 50);
                    } else {
                        // Clear everything first
                        this.editor.innerHTML = '';

                        // Create a proper empty line structure
                        const emptyLine = document.createElement('div');
                        emptyLine.className = 'editor-line editing';
                        emptyLine.dataset.lineIndex = '0';

                        // Add zero-width space for cursor visibility
                        const textNode = document.createTextNode('\u200B');
                        emptyLine.appendChild(textNode);
                        this.editor.appendChild(emptyLine);
                    }

                    // Ensure the editor is focusable and properly set up
                    this.editor.setAttribute('contenteditable', 'true');

                    // Force a focus/blur cycle to ensure event handlers are properly attached
                    setTimeout(() => {
                        this.editor.focus();
                        setTimeout(() => {
                            this.editor.blur();
                        }, 50);
                    }, 100);

                    this.isInitialized = true;

                    // Set up periodic health check
                    setInterval(() => this.checkAndFixEditorState(), 5000);
                    setInterval(() => this.ensureCursorVisible(), 1000);

                } catch (error) {
                    // Fallback initialization
                    const fallbackLine = document.createElement('div');
                    fallbackLine.className = 'editor-line editing';
                    fallbackLine.dataset.lineIndex = '0';
                    const textNode = document.createTextNode('\u200B');
                    fallbackLine.appendChild(textNode);
                    this.editor.innerHTML = '';
                    this.editor.appendChild(fallbackLine);
                    this.editor.setAttribute('contenteditable', 'true');
                    this.isInitialized = true;
                }
            }  
          // FIX: Render entire content as formatted with arrow rendering in initialization
            renderFormattedContent(content) {
                const lines = content.split('\n');
                this.editor.innerHTML = '';

                let actualLineIndex = 0;
                lines.forEach((line, index) => {
                    // Skip completely empty lines at the beginning and end, but preserve intentional empty lines
                    if (line.trim() === '' && (index === 0 || index === lines.length - 1)) {
                        return;
                    }

                    const lineDiv = document.createElement('div');
                    lineDiv.className = 'editor-line';
                    lineDiv.dataset.lineIndex = actualLineIndex++;

                    if (line.trim() === '') {
                        const textNode = document.createTextNode('\u200B');
                        lineDiv.appendChild(textNode);
                    } else if (line.startsWith('[TABLE]') && line.endsWith('[/TABLE]')) {
                        // Reconstruct table
                        const tableHTML = line.substring(7, line.length - 8);
                        lineDiv.innerHTML = tableHTML;
                        lineDiv.dataset.isTable = 'true';
                        lineDiv.contentEditable = 'false';
                    } else if (line.startsWith('[CODE]') && line.endsWith('[/CODE]')) {
                        // Reconstruct code block (unescape newlines)
                        const escapedContent = line.substring(6, line.length - 7);
                        const codeContent = escapedContent.replace(/<<<NEWLINE>>>/g, '\n');
                        lineDiv.dataset.isCodeBlock = 'true';
                        lineDiv.contentEditable = 'false';
                        
                        const isDark = document.body.classList.contains('dark');
                        const codeContainer = document.createElement('div');
                        codeContainer.className = 'code-block-container';
                        codeContainer.style.cssText = `background: ${isDark ? '#2a2a2a' : '#f5f5f5'}; border-left: 3px solid ${isDark ? '#4fc3f7' : '#007acc'}; border-radius: 4px; margin: 8px 0; overflow: hidden;`;
                        
                        const codeHeader = document.createElement('div');
                        codeHeader.className = 'code-block-header';
                        codeHeader.style.cssText = `padding: 4px 12px; background: ${isDark ? '#1f1f1f' : '#e8e8e8'}; font-family: monospace; font-size: 12px; color: ${isDark ? '#888' : '#666'}; border-bottom: 1px solid ${isDark ? '#444' : '#ddd'};`;
                        codeHeader.textContent = 'code';
                        
                        const codeArea = document.createElement('pre');
                        codeArea.contentEditable = 'true';
                        codeArea.className = 'code-block-content';
                        codeArea.style.cssText = `margin: 0; padding: 12px; font-family: monospace; white-space: pre; overflow-x: auto; outline: none; min-height: 60px; background: ${isDark ? '#2a2a2a' : '#f5f5f5'}; color: ${isDark ? '#d0d0d0' : '#3b3a3a'};`;
                        codeArea.textContent = codeContent;
                        
                        codeContainer.appendChild(codeHeader);
                        codeContainer.appendChild(codeArea);
                        lineDiv.appendChild(codeContainer);
                    } else {
                        const formattedElement = this.renderer.parseLine(line);

                        // Check if this is a heading
                        const isHeading = this.isHeadingLine(line);

                        if (isHeading) {
                            lineDiv.classList.add('heading');
                            lineDiv.dataset.headingLevel = isHeading;

                            // Get the formatted heading element
                            if (formattedElement.tagName === 'DIV') {
                                lineDiv.innerHTML = formattedElement.innerHTML;
                            } else {
                                lineDiv.appendChild(formattedElement);
                            }

                            // FIX: Add arrow rendering to initialization - Now add the arrow INSIDE the heading element
                            const headingElement = lineDiv.querySelector('h1, h2, h3, h4, h5, h6');
                            if (headingElement) {
                                this.addCollapseArrow(headingElement, lineDiv);
                            }
                        } else {
                            // Not a heading, add content normally
                            if (formattedElement.tagName === 'DIV') {
                                lineDiv.innerHTML = formattedElement.innerHTML;
                            } else {
                                lineDiv.appendChild(formattedElement);
                            }
                        }
                    }

                    this.editor.appendChild(lineDiv);
                });

                // Update line numbers after rendering content
                setTimeout(() => {
                    this.updateLineNumbersNow();
                }, 50);
            }      
      // Check if a line is a heading and return its level
            isHeadingLine(line) {
                const headingMatch = line.match(/^(#{1,6})\s/);
                const result = headingMatch ? headingMatch[1].length : false;
                return result;
            }

            // FIX: Fixed duplicate line in addCollapseArrow function
            addCollapseArrow(headingElement, lineDiv) {
                // Check if arrow already exists to prevent duplicates
                if (headingElement.querySelector('.collapse-arrow')) {
                    return;
                }

                const arrow = document.createElement('span');
                arrow.className = 'collapse-arrow';
                arrow.style.userSelect = 'none';
                arrow.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    setTimeout(() => this.toggleCollapse(lineDiv), 0);
                });
                arrow.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                });
                headingElement.insertBefore(arrow, headingElement.firstChild);
            }

            // Toggle collapse/expand for a heading
            toggleCollapse(headingLine) {
                const arrow = headingLine.querySelector('.collapse-arrow');
                if (!arrow) return;

                const headingLevel = parseInt(headingLine.dataset.headingLevel);
                const isCollapsed = arrow.classList.contains('collapsed');

                if (isCollapsed) {
                    // Expand
                    arrow.classList.remove('collapsed');
                    this.expandSection(headingLine, headingLevel);
                    headingLine.classList.remove('has-collapsed-content');
                } else {
                    // Before collapsing, ensure there's always an editable line available
                    const allLines = this.editor.querySelectorAll('.editor-line');
                    const visibleLines = Array.from(allLines).filter(line => !line.classList.contains('collapsed'));

                    // If this would be the only visible line after collapse, add a safety line
                    if (visibleLines.length <= 1) {
                        const safetyLine = document.createElement('div');
                        safetyLine.className = 'editor-line';
                        const textNode = document.createTextNode('\u200B');
                        safetyLine.appendChild(textNode);
                        safetyLine.dataset.lineIndex = allLines.length;
                        this.editor.appendChild(safetyLine);
                    }

                    // Collapse
                    arrow.classList.add('collapsed');
                    this.collapseSection(headingLine, headingLevel);
                    headingLine.classList.add('has-collapsed-content');
                }
            }       
     // Enhanced collapse section that preserves nested heading states
            collapseSection(headingLine, headingLevel) {
                let currentLine = headingLine.nextElementSibling;

                while (currentLine) {
                    const currentLineText = this.getLineRawContent(currentLine);
                    const currentHeadingLevel = this.isHeadingLine(currentLineText);

                    // Stop if we hit a heading of equal or higher level (lower number)
                    if (currentHeadingLevel && currentHeadingLevel <= headingLevel) {
                        break;
                    }

                    const nextLine = currentLine.nextElementSibling;
                    
                    // Store the current state of nested headings before hiding
                    if (currentLine.classList.contains('heading')) {
                        const nestedArrow = currentLine.querySelector('.collapse-arrow');
                        if (nestedArrow) {
                            currentLine.dataset.wasCollapsed = nestedArrow.classList.contains('collapsed').toString();
                        }
                    }
                    
                    // Hide this line
                    currentLine.classList.add('collapsed');
                    currentLine = nextLine;
                }

                // Update line numbers after collapsing
                this.updateLineNumbers();
            }

            // Enhanced expand section that preserves nested heading states
            expandSection(headingLine, headingLevel) {
                let currentLine = headingLine.nextElementSibling;

                while (currentLine) {
                    // Check if this line should stop the expansion
                    const currentLineText = this.getLineRawContent(currentLine);
                    const currentHeadingLevel = this.isHeadingLine(currentLineText);

                    // Stop if we hit a heading of equal or higher level (lower number)
                    if (currentHeadingLevel && currentHeadingLevel <= headingLevel) {
                        break;
                    }

                    const nextLine = currentLine.nextElementSibling;
                    
                    // Show this line if it was collapsed by THIS heading
                    if (currentLine.classList.contains('collapsed')) {
                        currentLine.classList.remove('collapsed');
                        
                        // If this is a nested heading that was previously collapsed, 
                        // restore its previous collapse state
                        if (currentLine.classList.contains('heading')) {
                            const nestedArrow = currentLine.querySelector('.collapse-arrow');
                            if (nestedArrow) {
                                const wasNestedCollapsed = currentLine.dataset.wasCollapsed === 'true';
                                if (wasNestedCollapsed) {
                                    nestedArrow.classList.add('collapsed');
                                    currentLine.classList.add('has-collapsed-content');
                                } else {
                                    nestedArrow.classList.remove('collapsed');
                                    currentLine.classList.remove('has-collapsed-content');
                                }
                                // Clean up the temporary data
                                delete currentLine.dataset.wasCollapsed;
                            }
                        }
                    }

                    currentLine = nextLine;
                }

                // Update line numbers after expanding
                this.updateLineNumbers();
            }            
// Update line numbers (with optional immediate mode for rapid operations)
            updateLineNumbers(immediate = false) {
                if (immediate) {
                    // Immediate update for rapid operations
                    if (window.updateAll) {
                        window.updateAll();
                    }
                } else {
                    // Delayed update for normal operations
                    setTimeout(() => {
                        if (window.updateAll) {
                            window.updateAll();
                        }
                    }, 0);
                }
            }

            // Force immediate line number update (for rapid operations)
            updateLineNumbersImmediate() {
                this.updateLineNumbers(true);
            }

            // Check and fix editor state if needed
            checkAndFixEditorState() {
                // Check if editor has proper structure
                const lines = this.editor.querySelectorAll('.editor-line');
                if (lines.length === 0) {
                    this.createMinimumStructure();
                }

                // Ensure contenteditable is set
                if (this.editor.getAttribute('contenteditable') !== 'true') {
                    this.editor.setAttribute('contenteditable', 'true');
                }
            }

            // Ensure minimum structure exists
            ensureMinimumStructure() {
                const lines = this.editor.querySelectorAll('.editor-line');
                if (lines.length === 0) {
                    this.createMinimumStructure();
                }
            }

            // Create the minimum required structure
            createMinimumStructure() {
                const emptyLine = document.createElement('div');
                emptyLine.className = 'editor-line editing';
                emptyLine.dataset.lineIndex = '0';

                // Add zero-width space for better cursor visibility
                const textNode = document.createTextNode('\u200B');
                emptyLine.appendChild(textNode);

                this.editor.appendChild(emptyLine);

                // Position cursor in the new line
                setTimeout(() => {
                    const range = document.createRange();
                    const selection = window.getSelection();
                    range.setStart(textNode, 0);
                    range.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(range);
                    this.editor.focus();
                }, 0);
            }     
       // Check if select-all is active
            isSelectAllActive() {
                const selection = window.getSelection();
                if (!selection.rangeCount) return false;

                const range = selection.getRangeAt(0);
                const selectedText = range.toString();
                const allText = this.editor.textContent || '';

                // Check if all or most content is selected
                return selectedText.length > 0 && selectedText.length >= allText.length * 0.9;
            }

            // Handle select-all delete safely
            handleSelectAllDelete() {
                // Clear all content but maintain structure
                this.editor.innerHTML = '';
                this.createMinimumStructure();

                // Ensure cursor is positioned at the start for immediate typing
                setTimeout(() => {
                    const firstLine = this.editor.querySelector('.editor-line');
                    if (firstLine) {
                        // Make sure the line is in edit mode with proper cursor support
                        firstLine.classList.add('editing');

                        // Clear and add zero-width space for cursor visibility
                        firstLine.innerHTML = '';
                        firstLine.textContent = '';
                        const textNode = document.createTextNode('\u200B');
                        firstLine.appendChild(textNode);

                        this.currentEditingLineElement = firstLine;

                        // Position cursor at the start of the line
                        const range = document.createRange();
                        const selection = window.getSelection();

                        range.setStart(textNode, 0);
                        range.collapse(true);

                        selection.removeAllRanges();
                        selection.addRange(range);

                        // Focus the editor to ensure cursor is visible
                        this.editor.focus();
                    }
                }, 50); // Slightly longer delay to ensure DOM is ready

                // Update line numbers and status
                this.updateLineNumbers();
            }

            // Ensure cursor is visible and properly positioned
            ensureCursorVisible() {
                try {
                    const selection = window.getSelection();

                    // Check if we have a valid selection
                    if (!selection.rangeCount) {
                        this.restoreCursor();
                        return;
                    }

                    // Check if the selection is within the editor
                    const range = selection.getRangeAt(0);
                    if (!this.editor.contains(range.commonAncestorContainer)) {
                        this.restoreCursor();
                        return;
                    }

                    // Check if cursor is in a valid line
                    const currentLine = this.getCurrentLineElement();
                    if (!currentLine) {
                        this.restoreCursor();
                        return;
                    }

                    // Additional check: ensure the line is still in the DOM
                    if (!currentLine.parentNode) {
                        this.restoreCursor();
                        return;
                    }
                } catch (error) {
                    // Fallback: try to restore cursor
                    setTimeout(() => this.restoreCursor(), 10);
                }
            }           
 // Restore cursor to a safe position
            restoreCursor() {
                // Find the current editing line or create one
                let targetLine = this.currentEditingLineElement;

                if (!targetLine || !targetLine.parentNode) {
                    // Find any available line
                    const lines = this.editor.querySelectorAll('.editor-line');
                    if (lines.length > 0) {
                        targetLine = lines[lines.length - 1]; // Use last line
                    } else {
                        // Create a new line if none exist
                        this.createMinimumStructure();
                        targetLine = this.editor.querySelector('.editor-line');
                    }
                }

                if (targetLine) {
                    // Ensure the line is in edit mode
                    if (!targetLine.classList.contains('editing')) {
                        this.makeLineEditable(targetLine);
                    }

                    // Position cursor at the end of the line
                    const textContent = targetLine.textContent || '';
                    this.setCursorInLineSafe(targetLine, textContent.length);

                    // Update current editing line reference
                    this.currentEditingLineElement = targetLine;
                }
            }

            // Enhanced cursor positioning with error handling
            setCursorInLineSafe(lineElement, position) {
                try {
                    this.setCursorInLine(lineElement, position);
                } catch (error) {
                    // Fallback: just focus the editor
                    this.editor.focus();

                    // Try to restore cursor after a delay
                    setTimeout(() => {
                        this.restoreCursor();
                    }, 10);
                }
            }

            // Handle input changes
            handleInput(e) {
                const currentLine = this.getCurrentLineElement();
                if (!currentLine) return;

                // NEW: Better undo system - save immediately if 10+ characters changed
                this.saveStateIfSignificantChange();

                // FIX: Only schedule delayed formatting for lists (less aggressive approach)
                this.scheduleDelayedListFormatting(currentLine);

                // Clean up zero-width spaces when user starts typing
                const content = currentLine.textContent || '';
                if (content.includes('\u200B') && content.length > 1) {
                    // Get the current cursor position before cleaning
                    const selection = window.getSelection();
                    let cursorOffset = 0;

                    if (selection.rangeCount > 0) {
                        const range = selection.getRangeAt(0);
                        if (range.startContainer.nodeType === Node.TEXT_NODE) {
                            cursorOffset = range.startOffset;
                        }
                    }

                    // Remove zero-width spaces when there's actual content
                    const cleanContent = content.replace(/\u200B/g, '');

                    // Set clean content
                    currentLine.textContent = cleanContent;

                    // Position cursor correctly - if we were at position 1 (after zero-width space),
                    // we should now be at position 1 in the clean content (after the first character)
                    setTimeout(() => {
                        if (currentLine.firstChild && currentLine.firstChild.nodeType === Node.TEXT_NODE) {
                            const range = document.createRange();
                            const sel = window.getSelection();
                            const textNode = currentLine.firstChild;

                            // If cursor was after the zero-width space (position 1), keep it at position 1
                            // If cursor was at the zero-width space (position 0), move it to position 1
                            const targetPos = Math.max(1, cursorOffset);
                            const finalPos = Math.min(targetPos, textNode.textContent.length);

                            range.setStart(textNode, finalPos);
                            range.collapse(true);
                            sel.removeAllRanges();
                            sel.addRange(range);
                        }
                    }, 0);
                }

                // Update the current line's content
                this.updateCurrentLineContent();
            }

            // Save state only if there are at least 10 characters of change
            saveStateIfSignificantChange() {
                const currentContent = this.getAllContent();
                
                // Get the last saved state
                const lastState = this.history[this.historyIndex] || '';
                
                // Calculate the difference in length
                const lengthDiff = Math.abs(currentContent.length - lastState.length);
                
                // Only save if there's at least 10 characters of change
                if (lengthDiff >= 10) {
                    this.saveState();
                }
            }

            // FIX: Force immediate re-render for lists with formatting
            handleImmediateListRerender(currentLine) {
                if (!currentLine) return;
                
                const content = currentLine.textContent || '';
                
                // Check if this is a list item with potential formatting
                const isUnorderedList = content.match(/^(\s*)[-*+] (.+)$/);
                const isOrderedList = content.match(/^(\s*)(\d+)\. (.+)$/);
                
                if ((isUnorderedList || isOrderedList) && content.includes('**')) {
                    // Schedule immediate re-render for lists with bold formatting
                    setTimeout(() => {
                        if (!currentLine.classList.contains('editing')) {
                            // Line is already formatted, force re-render to ensure bold text shows
                            const rawContent = this.getLineRawContent(currentLine);
                            const formattedElement = this.renderer.parseLine(rawContent);
                            
                            // Clear and re-add content
                            currentLine.innerHTML = '';
                            if (formattedElement.tagName === 'DIV') {
                                currentLine.innerHTML = formattedElement.innerHTML;
                            } else {
                                currentLine.appendChild(formattedElement);
                            }
                        }
                    }, 10);
                }
            }

            // FIX: Schedule delayed formatting for lists (triggers after user stops typing)
            scheduleDelayedListFormatting(currentLine) {
                if (!currentLine) return;
                
                // Clear any existing timeout
                if (this.delayedFormatTimeout) {
                    clearTimeout(this.delayedFormatTimeout);
                }
                
                // Set new timeout to format after 1 second of no typing (longer delay to avoid cursor issues)
                this.delayedFormatTimeout = setTimeout(() => {
                    const content = currentLine.textContent || '';
                    const isUnorderedList = content.match(/^(\s*)[-*+] (.+)$/);
                    const isOrderedList = content.match(/^(\s*)(\d+)\. (.+)$/);
                    
                    if ((isUnorderedList || isOrderedList) && content.includes('**') && currentLine.classList.contains('editing')) {
                        // Only format if the user is not actively typing (check if line still has focus)
                        const selection = window.getSelection();
                        if (selection.rangeCount > 0 && currentLine.contains(selection.getRangeAt(0).commonAncestorContainer)) {
                            // User is still in this line, don't format yet
                            return;
                        }
                        
                        // Temporarily format the line to show bold text
                        this.formatLine(currentLine);
                        
                        // Switch back to edit mode after a brief moment
                        setTimeout(() => {
                            this.makeLineEditable(currentLine);
                        }, 100);
                    }
                }, 1000);
            }     
       // Handle selection changes to switch between raw/formatted lines
            handleSelectionChange() {
                // Don't do anything in view mode - it's read-only, no line switching
                if (document.body.classList.contains('view-mode')) {
                    return;
                }
                
                // Don't do line switching in source mode - keep everything as raw markdown
                if (document.body.classList.contains('source-mode')) {
                    return;
                }
                
                // Don't interfere while user is actively selecting (dragging)
                if (this.isSelecting) {
                    return;
                }
                
                // Prevent re-entry while processing
                if (this.isProcessingSelection) {
                    return;
                }
                
                // Add a small delay to ensure DOM is stable
                setTimeout(() => {
                    const selection = window.getSelection();
                    if (!selection.rangeCount) {
                        // No selection - clear any multi-line selection
                        this.clearMultiLineSelection();
                        return;
                    }

                    // Check if user is making a text selection (not just clicking)
                    const range = selection.getRangeAt(0);
                    const isTextSelection = !range.collapsed; // Range is not collapsed = text is selected

                    // Allow normal text selection (multi-line feature disabled for stability)
                    if (isTextSelection) {
                        // Just allow normal selection, don't interfere
                        return;
                    }

                    const newLineElement = this.getCurrentLineElement();

                    // Only proceed if we actually have a line element
                    if (!newLineElement) return;

                    // Don't switch to edit mode if we're clicking on a collapse arrow
                    const clickedElement = range.startContainer.nodeType === Node.TEXT_NODE
                        ? range.startContainer.parentNode
                        : range.startContainer;

                    if (clickedElement && (clickedElement.classList.contains('collapse-arrow') ||
                        clickedElement.closest('.collapse-arrow'))) {
                        return;
                    }

                    if (newLineElement !== this.currentEditingLineElement) {
                        // Check if the new line is a collapsed heading - don't allow editing
                        const isCollapsedHeading = newLineElement.classList.contains('heading') &&
                            newLineElement.classList.contains('has-collapsed-content');

                        if (isCollapsedHeading) {
                            return;
                        }

                        // Check if the new line is a table or code block - don't allow editing
                        if (newLineElement.dataset.isTable === 'true' || newLineElement.dataset.isCodeBlock === 'true') {
                            return;
                        }

                        // Format the previous line if it exists
                        if (this.currentEditingLineElement && this.currentEditingLineElement.parentNode) {
                            this.formatLine(this.currentEditingLineElement);
                            
                            // FIX: Apply double-render for lists when switching lines
                            this.applyDoubleRenderForLists(this.currentEditingLineElement);
                            
                            // Check for code block pattern (``` ... ```)
                            this.detectAndConvertCodeBlock(this.currentEditingLineElement);
                        }

                        // Switch to raw mode for new line
                        this.makeLineEditable(newLineElement);
                        this.currentEditingLineElement = newLineElement;
                        
                        // Immediately update line numbers when switching lines
                        this.updateLineNumbersNow();
                        
                        // Immediately update minimap to highlight current line
                        if (window.minimapManager) {
                            window.minimapManager.update();
                        }
                    }

                    // Line numbers will update automatically via MutationObserver
                }, 10);
            }
            
            // Handle multi-line selection - show raw markdown for all selected lines
            handleMultiLineSelection(range) {
                try {
                    this.isProcessingSelection = true;
                    
                    // Get all lines in the editor
                    const allLines = this.editor.querySelectorAll('.editor-line');
                    const selectedLines = new Set();
                    
                    // Find which lines are part of the selection
                    for (let line of allLines) {
                        if (range.intersectsNode(line)) {
                            selectedLines.add(line);
                        }
                    }
                    
                    // Only process if we have multiple lines selected (not just text within one line)
                    if (selectedLines.size > 1) {
                        // Check if lines are already in edit mode
                        const allAlreadyEditing = Array.from(selectedLines).every(line => 
                            line.classList.contains('editing')
                        );
                        
                        if (allAlreadyEditing) {
                            // Already processed, just update the stored selection
                            this.multiLineSelection = selectedLines;
                            this.isProcessingSelection = false;
                            return;
                        }
                        
                        // Make all selected lines editable (show raw markdown)
                        selectedLines.forEach(line => {
                            if (!line.classList.contains('editing')) {
                                this.makeLineEditable(line);
                            }
                        });
                        
                        // Format all non-selected lines
                        allLines.forEach(line => {
                            if (!selectedLines.has(line) && line.classList.contains('editing')) {
                                this.formatLine(line);
                            }
                        });
                        
                        // Store the selected lines for later cleanup
                        this.multiLineSelection = selectedLines;
                        
                        // Update line numbers
                        this.updateLineNumbersNow();
                        
                        this.isProcessingSelection = false;
                    } else {
                        this.isProcessingSelection = false;
                    }
                    // If only one line is selected, do nothing - allow normal text selection
                } catch (error) {
                    console.error('Multi-line selection error:', error);
                    this.isProcessingSelection = false;
                }
            }

            
            // Clear multi-line selection and format all lines
            clearMultiLineSelection() {
                if (this.multiLineSelection && this.multiLineSelection.size > 0) {
                    // Format all previously selected lines
                    this.multiLineSelection.forEach(line => {
                        if (line.classList.contains('editing') && line.parentNode) {
                            this.formatLine(line);
                        }
                    });
                    
                    this.multiLineSelection = null;
                    this.updateLineNumbersNow();
                }
            }

            // Get the current line element containing the cursor
            getCurrentLineElement() {
                const selection = window.getSelection();
                if (!selection.rangeCount) return null;

                let node = selection.getRangeAt(0).startContainer;

                // If we're in a text node, get its parent
                if (node.nodeType === Node.TEXT_NODE) {
                    node = node.parentNode;
                }

                // Walk up to find the line div
                let attempts = 0;
                while (node && node !== this.editor && attempts < 10) {
                    if (node.nodeType === Node.ELEMENT_NODE && node.classList && node.classList.contains('editor-line')) {
                        return node;
                    }
                    node = node.parentNode;
                    attempts++;
                }

                // Fallback: if we can't find the line, try to find it by position
                const lines = this.editor.querySelectorAll('.editor-line');
                if (lines.length === 0) return null;

                // Return the first line as fallback
                return lines[0];
            }
            
            // Get line element from mouse coordinates
            getLineFromPoint(x, y) {
                const element = document.elementFromPoint(x, y);
                if (!element) return null;
                
                // Walk up to find the editor-line
                let node = element;
                let attempts = 0;
                while (node && node !== this.editor && attempts < 10) {
                    if (node.classList && node.classList.contains('editor-line')) {
                        return node;
                    }
                    node = node.parentNode;
                    attempts++;
                }
                
                return null;
            }      
      // Make a line editable (show raw markdown)
            makeLineEditable(lineElement) {
                // Don't switch to edit mode if already editing
                if (lineElement.classList.contains('editing')) {
                    return;
                }

                // In source mode, convert code blocks to ``` syntax
                if (document.body.classList.contains('source-mode')) {
                    if (lineElement.dataset.isCodeBlock === 'true') {
                        const codeArea = lineElement.querySelector('.code-block-content');
                        if (codeArea) {
                            const codeContent = codeArea.textContent || '';
                            const lines = codeContent.split('\n');
                            
                            // Create opening ```
                            const openLine = document.createElement('div');
                            openLine.className = 'editor-line editing';
                            openLine.textContent = '```';
                            
                            // Create content lines
                            const contentLines = lines.map(line => {
                                const div = document.createElement('div');
                                div.className = 'editor-line editing';
                                div.textContent = line;
                                return div;
                            });
                            
                            // Create closing ```
                            const closeLine = document.createElement('div');
                            closeLine.className = 'editor-line editing';
                            closeLine.textContent = '```';
                            
                            // Replace the code block with raw lines
                            lineElement.parentNode.insertBefore(openLine, lineElement);
                            contentLines.forEach(line => {
                                lineElement.parentNode.insertBefore(line, lineElement);
                            });
                            lineElement.parentNode.insertBefore(closeLine, lineElement);
                            lineElement.remove();
                            
                            this.updateLineIndices();
                            return;
                        }
                    }
                    
                    // In source mode, tables should also be converted (keep as is for now)
                    if (lineElement.dataset.isTable === 'true') {
                        return; // Tables remain as HTML for now
                    }
                } else {
                    // In edit/view mode, don't make tables or code blocks editable
                    if (lineElement.dataset.isTable === 'true' || lineElement.dataset.isCodeBlock === 'true') {
                        return;
                    }
                }

                const rawContent = this.getLineRawContent(lineElement);

                // Special handling for blank lines
                const isBlankLine = rawContent.trim() === '';

                if (isBlankLine) {
                    // For blank lines, clear content but ensure cursor visibility
                    lineElement.innerHTML = '';
                    lineElement.textContent = '';
                    lineElement.classList.add('editing');

                    // Ensure the line has proper structure for cursor visibility
                    // Add a zero-width space to make the line focusable
                    const textNode = document.createTextNode('\u200B'); // Zero-width space
                    lineElement.appendChild(textNode);

                    // Position cursor at start of blank line
                    setTimeout(() => {
                        const range = document.createRange();
                        const selection = window.getSelection();
                        range.setStart(textNode, 0);
                        range.collapse(true);
                        selection.removeAllRanges();
                        selection.addRange(range);

                        // Focus the editor to ensure cursor is visible
                        this.editor.focus();
                    }, 0);
                    return;
                }

                // Store cursor position as a ratio of the visible text length
                const selection = window.getSelection();
                let cursorRatio = 1; // Default to end of line
                if (selection.rangeCount > 0) {
                    const range = selection.getRangeAt(0);
                    if (lineElement.contains(range.startContainer)) {
                        const visibleText = lineElement.textContent || '';
                        const cursorPos = this.getCursorPositionInLine(lineElement);
                        cursorRatio = visibleText.length > 0 ? cursorPos / visibleText.length : 1;
                    }
                }

                // Simply set the text content - arrows will be re-added when formatting
                lineElement.innerHTML = '';
                lineElement.textContent = rawContent;
                lineElement.classList.add('editing');

                // Restore cursor position based on ratio
                setTimeout(() => {
                    const targetPos = Math.floor(rawContent.length * cursorRatio);
                    this.setCursorInLineSafe(lineElement, Math.min(targetPos, rawContent.length));
                }, 0);
            } 
           // Format a line (show formatted content)
            formatLine(lineElement) {
                // Don't format in source mode
                if (document.body.classList.contains('source-mode')) {
                    return;
                }
                
                const rawContent = lineElement.textContent || '';
                lineElement.classList.remove('editing');

                // Preserve collapse arrow if it exists
                const existingArrow = lineElement.querySelector('.collapse-arrow');
                const wasCollapsed = existingArrow && existingArrow.classList.contains('collapsed');

                if (rawContent.trim() === '') {
                    lineElement.innerHTML = '';
                    const textNode = document.createTextNode('\u200B');
                    lineElement.appendChild(textNode);
                } else {
                    const formattedElement = this.renderer.parseLine(rawContent);

                    // Check if this is a heading
                    const isHeading = this.isHeadingLine(rawContent);
                    if (isHeading) {
                        lineElement.classList.add('heading');
                        lineElement.dataset.headingLevel = isHeading;

                        // Clear content first
                        lineElement.innerHTML = '';

                        // Add formatted content
                        if (formattedElement.tagName === 'DIV') {
                            lineElement.innerHTML = formattedElement.innerHTML;
                        } else {
                            lineElement.appendChild(formattedElement);
                        }

                        // FIX: Add arrow rendering to re-rendering loop - Now add the arrow INSIDE the heading element
                        const headingElement = lineElement.querySelector('h1, h2, h3, h4, h5, h6');
                        if (headingElement) {
                            this.addCollapseArrow(headingElement, lineElement);
                            if (wasCollapsed) {
                                const arrow = headingElement.querySelector('.collapse-arrow');
                                arrow.classList.add('collapsed');
                                lineElement.classList.add('has-collapsed-content');
                            }
                        }
                    } else {
                        // Not a heading, remove heading classes
                        lineElement.classList.remove('heading', 'has-collapsed-content');
                        delete lineElement.dataset.headingLevel;
                        lineElement.innerHTML = '';

                        if (formattedElement.tagName === 'DIV') {
                            lineElement.innerHTML = formattedElement.innerHTML;
                        } else {
                            lineElement.appendChild(formattedElement);
                        }
                    }
                }

                // FIX: Enhanced double-render logic for both ordered and unordered lists
                setTimeout(() => {
                    const isUnorderedList = rawContent.match(/^(\s*)[-*+] (.+)$/);
                    const isOrderedList = rawContent.match(/^(\s*)(\d+)\. (.+)$/);
                    
                    if (isUnorderedList || isOrderedList) {
                        // First render
                        const newFormattedElement = this.renderer.parseLine(rawContent);
                        lineElement.innerHTML = '';
                        if (newFormattedElement.tagName === 'DIV') {
                            lineElement.innerHTML = newFormattedElement.innerHTML;
                        } else {
                            lineElement.appendChild(newFormattedElement);
                        }
                        
                        // FIX: Second render for better formatting consistency (same logic for both list types)
                        setTimeout(() => {
                            const secondFormattedElement = this.renderer.parseLine(rawContent);
                            lineElement.innerHTML = '';
                            if (secondFormattedElement.tagName === 'DIV') {
                                lineElement.innerHTML = secondFormattedElement.innerHTML;
                            } else {
                                lineElement.appendChild(secondFormattedElement);
                            }
                        }, 25);
                    }
                }, 0);

                // Line numbers will update automatically via MutationObserver when content changes
            }  
          // FIX: Fixed getLineRawContent to call extractLineMarkdown instead of extractMarkdown
            getLineRawContent(lineElement) {
                if (lineElement.classList.contains('editing')) {
                    const content = lineElement.textContent || '';
                    // Remove zero-width spaces used for cursor visibility
                    return content.replace(/\u200B/g, '');
                }

                // Check if this is an empty line (only contains <br> or zero-width space)
                if (lineElement.innerHTML === '<br>' || lineElement.innerHTML.trim() === '<br>' ||
                    lineElement.textContent === '\u200B') {
                    return ''; // Return empty string, not newline
                }

                // Handle tables - save as special marker with HTML
                if (lineElement.dataset.isTable === 'true') {
                    const table = lineElement.querySelector('table');
                    if (table) {
                        return `[TABLE]${table.outerHTML}[/TABLE]`;
                    }
                    return '[TABLE][/TABLE]';
                }

                // Handle code blocks - save as special marker with content (escape newlines)
                if (lineElement.dataset.isCodeBlock === 'true') {
                    const codeArea = lineElement.querySelector('.code-block-content');
                    if (codeArea) {
                        const codeContent = codeArea.textContent || '';
                        // Replace actual newlines with a unique placeholder so they survive the split('\n')
                        // Use a more unique marker to avoid conflicts
                        const escapedContent = codeContent.replace(/\n/g, '<<<NEWLINE>>>');
                        return `[CODE]${escapedContent}[/CODE]`;
                    }
                    return '[CODE][/CODE]';
                }

                // For headings with arrows, extract text from the heading element
                const headingElement = lineElement.querySelector('h1, h2, h3, h4, h5, h6');
                if (headingElement) {
                    // Get the heading level from the tag name
                    const level = parseInt(headingElement.tagName.charAt(1));
                    const prefix = '#'.repeat(level) + ' ';

                    // Get text content, excluding the arrow
                    let text = '';
                    for (let node of headingElement.childNodes) {
                        if (node.nodeType === Node.TEXT_NODE) {
                            text += node.textContent;
                        } else if (node.nodeType === Node.ELEMENT_NODE && !node.classList.contains('collapse-arrow')) {
                            text += node.textContent;
                        }
                    }
                    return prefix + text.trim();
                }

                // FIX: For non-headings, use extractLineMarkdown instead of extractMarkdown
                return this.renderer.extractLineMarkdown(lineElement) || lineElement.textContent || '';
            }

            // Format all lines (used on blur)
            formatAllLines() {
                const lines = this.editor.querySelectorAll('.editor-line');
                lines.forEach(line => {
                    if (line.classList.contains('editing')) {
                        this.formatLine(line);
                    }
                });
                this.currentEditingLineElement = null;
            }

            // FIX: Add arrow rendering to forceRenderAllLines function
            forceRenderAllLines() {
                const lines = this.editor.querySelectorAll('.editor-line');
                lines.forEach(line => {
                    // Skip code blocks and tables - they're already properly formatted
                    if (line.dataset.isCodeBlock === 'true' || line.dataset.isTable === 'true') {
                        return;
                    }
                    
                    // Get raw content
                    const rawContent = this.getLineRawContent(line);

                    // Re-render the line
                    if (rawContent.trim() === '') {
                        line.innerHTML = '';
                        const textNode = document.createTextNode('\u200B');
                        line.appendChild(textNode);
                    } else {
                        const formattedElement = this.renderer.parseLine(rawContent);
                        line.classList.remove('editing');
                        line.innerHTML = '';

                        if (formattedElement.tagName === 'DIV') {
                            line.innerHTML = formattedElement.innerHTML;
                        } else {
                            line.appendChild(formattedElement);
                        }

                        // FIX: Add arrow rendering to forceRenderAllLines - Check if this is a heading and add arrow
                        const isHeading = this.isHeadingLine(rawContent);
                        if (isHeading) {
                            line.classList.add('heading');
                            line.dataset.headingLevel = isHeading;

                            const headingElement = line.querySelector('h1, h2, h3, h4, h5, h6');
                            if (headingElement) {
                                this.addCollapseArrow(headingElement, line);
                            }
                        }
                    }
                });

                // Force line number update after re-rendering (this is intentional)
                this.scheduleLineNumberUpdate();
            } 
           // Update current line content and handle line breaks
            updateCurrentLineContent() {
                const currentLine = this.currentEditingLineElement;
                if (!currentLine) return;

                const content = currentLine.textContent || '';
                const lines = content.split('\n');

                if (lines.length > 1) {
                    // Handle line breaks - split into multiple lines
                    this.splitLine(currentLine, lines);
                }
            }

            // Split a line into multiple lines
            splitLine(lineElement, lines) {
                const lineIndex = parseInt(lineElement.dataset.lineIndex);
                const selection = window.getSelection();
                const cursorPos = this.getCursorPositionInLine(lineElement);

                // Update current line with first part
                lineElement.textContent = lines[0];

                // Insert new lines for the rest
                lines.slice(1).forEach((line, index) => {
                    const newLineDiv = document.createElement('div');
                    newLineDiv.className = 'editor-line';
                    newLineDiv.dataset.lineIndex = lineIndex + index + 1;
                    newLineDiv.textContent = line;

                    lineElement.parentNode.insertBefore(newLineDiv, lineElement.nextSibling);
                    lineElement = newLineDiv; // Update reference for next iteration
                });

                // Update line indices for all subsequent lines
                this.updateLineIndices();

                // Restore cursor position in the new line
                const newCurrentLine = this.editor.querySelector(`[data-line-index="${lineIndex + 1}"]`);
                if (newCurrentLine) {
                    this.setCursorInLine(newCurrentLine, 0);
                    this.currentEditingLineElement = newCurrentLine;
                    this.makeLineEditable(newCurrentLine);
                }
            }

            // Update line indices after splitting/merging
            updateLineIndices() {
                const lines = this.editor.querySelectorAll('.editor-line');
                lines.forEach((line, index) => {
                    line.dataset.lineIndex = index;
                });
            }

            // Get cursor position within a line
            getCursorPositionInLine(lineElement) {
                const selection = window.getSelection();
                if (!selection.rangeCount) return 0;

                const range = selection.getRangeAt(0);
                const preCaretRange = range.cloneRange();
                preCaretRange.selectNodeContents(lineElement);
                preCaretRange.setEnd(range.endContainer, range.endOffset);

                return preCaretRange.toString().length;
            }     
       // Set cursor position within a line
            setCursorInLine(lineElement, position) {
                const selection = window.getSelection();
                const range = document.createRange();

                let currentPos = 0;
                const walker = document.createTreeWalker(
                    lineElement,
                    NodeFilter.SHOW_TEXT,
                    null,
                    false
                );

                let node;
                while (node = walker.nextNode()) {
                    const nodeLength = node.textContent.length;
                    if (currentPos + nodeLength >= position) {
                        range.setStart(node, Math.min(position - currentPos, nodeLength));
                        range.setEnd(node, Math.min(position - currentPos, nodeLength));
                        break;
                    }
                    currentPos += nodeLength;
                }

                selection.removeAllRanges();
                selection.addRange(range);
            }

            // Get all content as raw markdown
            getAllContent() {
                const lines = this.editor.querySelectorAll('.editor-line');
                const content = [];

                lines.forEach((line, index) => {
                    const rawContent = this.getLineRawContent(line);
                    content.push(rawContent);
                });

                const result = content.join('\n');
                return result;
            }

            // Check if currently in edit mode (always true for line-based editing)
            isEditing() {
                return true; // Always in edit mode for line-based editing
            }

            // Debug method to check editor state
            debugEditorState() {
                const lines = this.editor.querySelectorAll('.editor-line');
                lines.forEach((line, i) => {
                    // Debug logging removed for cleaner code
                });
            }

            // Smart line number update scheduling with performance optimization
            scheduleLineNumberUpdate() {
                const now = Date.now();
                const timeSinceLastUpdate = now - this.lastLineNumberUpdate;

                // Detect rapid operations (multiple updates within 200ms)
                if (timeSinceLastUpdate < 200) {
                    this.isRapidOperation = true;
                    // Clear rapid operation flag after a delay
                    if (this.rapidOperationTimeout) {
                        clearTimeout(this.rapidOperationTimeout);
                    }
                    this.rapidOperationTimeout = setTimeout(() => {
                        this.isRapidOperation = false;
                    }, 500);
                }

                // Clear any pending update
                if (this.lineNumberUpdateTimeout) {
                    clearTimeout(this.lineNumberUpdateTimeout);
                }

                // During rapid operations, be more conservative
                if (this.isRapidOperation) {
                    // Longer debounce during rapid operations to prevent cursor issues
                    this.lineNumberUpdateTimeout = setTimeout(() => {
                        this.performLineNumberUpdate();
                    }, 300);
                } else if (timeSinceLastUpdate < 100) {
                    // Normal debounce
                    this.lineNumberUpdateTimeout = setTimeout(() => {
                        this.performLineNumberUpdate();
                    }, 150);
                } else {
                    // If it's been a while, update immediately
                    this.performLineNumberUpdate();
                }
            }    
        // Perform the actual line number update
            performLineNumberUpdate() {
                this.lastLineNumberUpdate = Date.now();
                // Only use our self-contained update, don't call the global system
                this.updateLineNumbersNow();
            }

            // SMART AUTO-MEASURING LINE NUMBER CALCULATION SYSTEM
            // This method measures actual rendered heights and positions line numbers perfectly
            calculateLineNumbers() {
                try {
                    const editorLines = this.editor.querySelectorAll('.editor-line');
                    let lineNumberElements = [];
                    let visibleLineCount = 0;

                    // Measure baseline line height using a dummy element
                    const baseLineHeight = this.measureBaseLineHeight();

                    if (editorLines.length === 0) {
                        return {
                            html: '<div class="line-number" style="top: 0px;">1</div>',
                            total: 1
                        };
                    }

                    const editorRect = this.editor.getBoundingClientRect();

                    // Process each visible line
                    for (let i = 0; i < editorLines.length; i++) {
                        const line = editorLines[i];

                        // Skip collapsed lines
                        if (line.classList.contains('collapsed')) {
                            continue;
                        }

                        visibleLineCount++;
                        const content = line.textContent.substring(0, 30) + (line.textContent.length > 30 ? '...' : '');

                        // Get actual rendered dimensions
                        const lineRect = line.getBoundingClientRect();
                        const relativeTop = lineRect.top - editorRect.top;
                        const lineHeight = lineRect.height;

                        // Calculate how many "text lines" this element represents
                        const textLines = Math.max(1, Math.round(lineHeight / baseLineHeight));

                        // Check if this is the current editing line
                        const isCurrent = line === this.currentEditingLineElement || line.classList.contains('editing');
                        const currentClass = isCurrent ? ' current' : '';

                        // Create ONE line number positioned at the top of this element
                        // Each DOM element (.editor-line) counts as exactly ONE logical line
                        const lineNumberHtml = `<div class="line-number${currentClass}" style="top: ${relativeTop}px;">${visibleLineCount}</div>`;
                        lineNumberElements.push(lineNumberHtml);

                        // Note: We don't create multiple line numbers for tall elements like headers
                        // The visual spacing is handled by the element's natural height
                    }

                    return {
                        html: lineNumberElements.join(''),
                        total: Math.max(1, visibleLineCount)
                    };

                } catch (error) {
                    // Fallback to simple calculation
                    return {
                        html: '<div class="line-number" style="top: 0px;">1</div>',
                        total: 1
                    };
                }
            }

            // Measure baseline line height for text
            measureBaseLineHeight() {
                const dummy = document.createElement('div');
                dummy.textContent = 'Ag'; // Characters with ascenders and descenders
                dummy.style.cssText = `
                    position: absolute;
                    visibility: hidden;
                    font-family: inherit;
                    font-size: inherit;
                    line-height: inherit;
                    margin: 0;
                    padding: 0;
                    border: 0;
                    white-space: nowrap;
                `;

                this.editor.appendChild(dummy);
                const height = dummy.getBoundingClientRect().height;
                dummy.remove();

                return height || 22; // Fallback to 22px if measurement fails
            } 
           // Self-contained line number update that uses the unified calculation
            updateLineNumbersNow() {
                try {
                    const lineNumbers = document.getElementById('lineNumbers');
                    const status = document.getElementById('status');

                    if (!lineNumbers || !status) {
                        return;
                    }

                    // Use smart auto-measuring calculation method
                    const result = this.calculateLineNumbers();

                    // Update line numbers with new HTML structure
                    lineNumbers.innerHTML = result.html;

                    // Update status
                    if (status) {
                        const text = this.getAllContent();
                        const cleanText = this.getCleanTextForCounting(text);
                        const chars = cleanText.length;
                        const words = cleanText.trim() ? cleanText.trim().split(/\s+/).length : 0;
                        const lines = result.total;
                        status.textContent = `Words: ${words} | Characters: ${chars} | Lines: ${lines}`;
                    }
                } catch (error) {
                    // Fallback
                    const lineNumbers = document.getElementById('lineNumbers');
                    if (lineNumbers) {
                        lineNumbers.innerHTML = '<div class="line-number" style="top: 0px;">1</div>';
                    }
                }
            }

            // Get clean text for counting (removes markdown syntax)
            getCleanTextForCounting(text) {
                if (!text) return '';

                return text
                    .replace(/\*\*(.*?)\*\*/g, '$1')  // Bold
                    .replace(/\*(.*?)\*/g, '$1')      // Italic
                    .replace(/~~(.*?)~~/g, '$1')      // Strikethrough
                    .replace(/==(.*?)==/g, '$1')      // Highlight
                    .replace(/^#{1,3}\s+/gm, '')      // Headings
                    .replace(/^(\s*)[-*+]\s+/gm, '$1') // Unordered lists
                    .replace(/^(\s*)\d+\.\s+/gm, '$1') // Ordered lists
                    .replace(/^(---|\*\*\*|___)$/gm, '') // Horizontal rules
                    .replace(/^\s*$/gm, '');          // Empty lines
            }

            // Force line number update with self-contained method only
            forceLineNumberUpdate() {
                this.debugEditorState();

                // Use only our self-contained update to avoid double rendering
                this.updateLineNumbersNow();

                // Single retry if needed
                setTimeout(() => {
                    this.updateLineNumbersNow();
                }, 100);
            }

            // Force complete re-initialization (useful after major content changes)
            forceReinitialize() {
                const content = this.editor.textContent || '';
                this.isInitialized = false;
                this.currentEditingLineElement = null;

                // Clear and reinitialize
                this.editor.innerHTML = '';
                if (content.trim()) {
                    this.editor.textContent = content;
                    this.initializeEditor();
                } else {
                    this.createMinimumStructure();
                }

                // Force line number update with retry logic
                setTimeout(() => this.forceLineNumberUpdate(), 100);
            } 
           // Undo/Redo System
            saveState() {
                const currentState = this.getAllContent();

                // Don't save if it's the same as the last saved state
                if (currentState === this.lastSavedState) {
                    return;
                }

                // Remove any states after current index (when we're in the middle of history)
                this.history = this.history.slice(0, this.historyIndex + 1);

                // Add new state
                this.history.push(currentState);
                this.historyIndex = this.history.length - 1;

                // Limit history size
                if (this.history.length > this.maxHistorySize) {
                    this.history.shift();
                    this.historyIndex--;
                }

                this.lastSavedState = currentState;
            }

            undo() {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    const state = this.history[this.historyIndex];
                    this.restoreState(state);
                    return true;
                }
                return false;
            }

            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.historyIndex++;
                    const state = this.history[this.historyIndex];
                    this.restoreState(state);
                    return true;
                }
                return false;
            }

            restoreState(content) {
                // Temporarily disable state saving during restore
                const originalSaveState = this.saveState;
                this.saveState = () => { };

                try {
                    // Clear editor and set content
                    this.editor.innerHTML = '';
                    this.editor.textContent = content;

                    // Reinitialize with the restored content
                    this.isInitialized = false;
                    this.currentEditingLineElement = null;
                    this.initializeEditor();

                    // Update last saved state to prevent duplicate saves
                    this.lastSavedState = content;
                } finally {
                    // Restore state saving
                    this.saveState = originalSaveState;
                }
            }  
          // Insert or toggle markdown syntax at cursor or around selection
            insertMarkdownSyntax(startSyntax, endSyntax = '', savedSelection = null) {
                const currentLine = this.getCurrentLineElement();
                if (!currentLine) return;

                // Ensure line is in edit mode
                if (!currentLine.classList.contains('editing')) {
                    // Save the current selection before switching modes
                    const selection = window.getSelection();
                    let selectionInfo = null;
                    
                    if (selection.rangeCount > 0) {
                        const range = selection.getRangeAt(0);
                        const selectedText = range.toString();
                        const startOffset = range.startOffset;
                        const endOffset = range.endOffset;
                        const startContainer = range.startContainer;
                        const endContainer = range.endContainer;
                        
                        selectionInfo = {
                            text: selectedText,
                            startOffset: startOffset,
                            endOffset: endOffset,
                            hasSelection: selectedText.length > 0
                        };
                    }
                    
                    this.makeLineEditable(currentLine);
                    
                    // Give the line time to switch to edit mode, then restore selection
                    setTimeout(() => {
                        if (selectionInfo && selectionInfo.hasSelection) {
                            // Try to restore the selection in the now-editable line
                            const textNode = currentLine.firstChild;
                            if (textNode && textNode.nodeType === Node.TEXT_NODE) {
                                const newRange = document.createRange();
                                const sel = window.getSelection();
                                
                                try {
                                    newRange.setStart(textNode, Math.min(selectionInfo.startOffset, textNode.length));
                                    newRange.setEnd(textNode, Math.min(selectionInfo.endOffset, textNode.length));
                                    sel.removeAllRanges();
                                    sel.addRange(newRange);
                                } catch (e) {
                                    // If restoration fails, just proceed with the saved info
                                }
                            }
                        }
                        this.insertMarkdownSyntax(startSyntax, endSyntax, selectionInfo);
                    }, 10);
                    return;
                }

                const selection = window.getSelection();
                if (!selection.rangeCount) return;

                const range = selection.getRangeAt(0);
                let selectedText = savedSelection ? savedSelection.text : range.toString();

                try {
                    if (selectedText && selectedText.length > 0) {
                        // Get the full line text to check context
                        const lineText = currentLine.textContent || '';
                        const startPos = this.getCursorPositionInLine(currentLine) - selectedText.length;
                        
                        // Check if there are markers before and after the selection in the line
                        const beforeText = lineText.substring(Math.max(0, startPos - startSyntax.length), startPos);
                        const afterPos = startPos + selectedText.length;
                        const afterText = lineText.substring(afterPos, afterPos + endSyntax.length);
                        
                        const hasMarkersAround = beforeText === startSyntax && afterText === endSyntax;
                        
                        if (hasMarkersAround) {
                            // Remove the markers around the selection
                            const beforeMarkerStart = Math.max(0, startPos - startSyntax.length);
                            const afterMarkerEnd = afterPos + endSyntax.length;
                            
                            const newText = lineText.substring(0, beforeMarkerStart) + 
                                          selectedText + 
                                          lineText.substring(afterMarkerEnd);
                            
                            currentLine.textContent = newText;
                            
                            // Position cursor after the unformatted text
                            setTimeout(() => {
                                this.setCursorInLine(currentLine, beforeMarkerStart + selectedText.length);
                            }, 0);
                        } else {
                            // Add formatting - wrap the selected text
                            const wrappedText = startSyntax + selectedText + endSyntax;
                            range.deleteContents();
                            const textNode = document.createTextNode(wrappedText);
                            range.insertNode(textNode);

                            // Position cursor after the wrapped text
                            setTimeout(() => {
                                const newPos = this.getCursorPositionInLine(currentLine);
                                this.setCursorInLine(currentLine, newPos);
                            }, 0);
                        }
                    } else {
                        // No selection - check if cursor is inside formatted text
                        const lineText = currentLine.textContent || '';
                        const cursorPos = this.getCursorPositionInLine(currentLine);
                        
                        // Try to find if cursor is within formatted text
                        const removed = this.tryRemoveFormattingAtCursor(currentLine, cursorPos, startSyntax, endSyntax);
                        
                        if (!removed) {
                            // Insert syntax at cursor position
                            const syntaxText = startSyntax + endSyntax;
                            const textNode = document.createTextNode(syntaxText);
                            range.insertNode(textNode);

                            // Position cursor between start and end syntax
                            if (endSyntax) {
                                const newRange = document.createRange();
                                newRange.setStart(textNode, startSyntax.length);
                                newRange.collapse(true);
                                selection.removeAllRanges();
                                selection.addRange(newRange);
                            }
                        }
                    }
                } catch (error) {
                    // Fallback: just insert the text
                    document.execCommand('insertText', false, startSyntax + (selectedText || '') + endSyntax);
                }
            }

            // Try to remove formatting at cursor position
            tryRemoveFormattingAtCursor(lineElement, cursorPos, startSyntax, endSyntax) {
                const lineText = lineElement.textContent || '';
                
                // Find all occurrences of this formatting in the line
                const startLen = startSyntax.length;
                const endLen = endSyntax.length;
                
                let searchPos = 0;
                while (searchPos < lineText.length) {
                    const startIdx = lineText.indexOf(startSyntax, searchPos);
                    if (startIdx === -1) break;
                    
                    const endIdx = lineText.indexOf(endSyntax, startIdx + startLen);
                    if (endIdx === -1) break;
                    
                    // Check if cursor is within this formatted region
                    if (cursorPos >= startIdx && cursorPos <= endIdx + endLen) {
                        // Remove the formatting
                        const before = lineText.substring(0, startIdx);
                        const content = lineText.substring(startIdx + startLen, endIdx);
                        const after = lineText.substring(endIdx + endLen);
                        
                        lineElement.textContent = before + content + after;
                        
                        // Position cursor in the unformatted content
                        const newCursorPos = startIdx + Math.min(cursorPos - startIdx, content.length);
                        this.setCursorInLine(lineElement, newCursorPos);
                        
                        return true;
                    }
                    
                    searchPos = endIdx + endLen;
                }
                
                return false;
            }

            // Apply formatting to selected text or at cursor
            applyFormatting(type) {
                const currentLine = this.getCurrentLineElement();
                if (!currentLine) return;

                const formatMap = {
                    'bold': ['**', '**'],
                    'italic': ['*', '*'],
                    'strikethrough': ['~~', '~~'],
                    'highlight': ['==', '=='],
                    'h1': ['# ', ''],
                    'h2': ['## ', ''],
                    'h3': ['### ', '']
                };

                if (formatMap[type]) {
                    const [start, end] = formatMap[type];
                    this.insertMarkdownSyntax(start, end);
                }
            } 
           // Remove formatting from selected text
            removeFormatting(type) {
                const currentLine = this.getCurrentLineElement();
                if (!currentLine) return;

                // Ensure line is in edit mode
                if (!currentLine.classList.contains('editing')) {
                    this.makeLineEditable(currentLine);
                }

                const selection = window.getSelection();
                if (!selection.rangeCount) return;

                const range = selection.getRangeAt(0);
                const selectedText = range.toString();

                const formatMap = {
                    'bold': [/^\*\*(.*)\*\*$/, '$1'],
                    'italic': [/^\*(.*)\*$/, '$1'],
                    'strikethrough': [/^~~(.*)~~$/, '$1'],
                    'highlight': [/^==(.*)==$/, '$1'],
                    'h1': [/^# (.*)$/, '$1'],
                    'h2': [/^## (.*)$/, '$1'],
                    'h3': [/^### (.*)$/, '$1']
                };

                if (formatMap[type] && selectedText) {
                    const [pattern, replacement] = formatMap[type];
                    const cleanText = selectedText.replace(pattern, replacement);

                    if (cleanText !== selectedText) {
                        range.deleteContents();
                        range.insertNode(document.createTextNode(cleanText));
                    }
                }
            }

            // Check if selection has specific formatting
            hasFormatting(type) {
                const currentLine = this.getCurrentLineElement();
                if (!currentLine || !currentLine.classList.contains('editing')) return false;

                const selection = window.getSelection();
                if (!selection.rangeCount) return false;

                const selectedText = selection.getRangeAt(0).toString();
                const lineText = currentLine.textContent || '';

                const formatMap = {
                    'bold': ['**', '**'],
                    'italic': ['*', '*'],
                    'strikethrough': ['~~', '~~'],
                    'highlight': ['==', '=='],
                    'h1': ['# ', ''],
                    'h2': ['## ', ''],
                    'h3': ['### ', '']
                };

                if (!formatMap[type]) return false;
                
                const [startSyntax, endSyntax] = formatMap[type];

                if (selectedText && selectedText.length > 0) {
                    // Check if selection is surrounded by markers in the line
                    const cursorPos = this.getCursorPositionInLine(currentLine);
                    const startPos = cursorPos - selectedText.length;
                    
                    const beforeText = lineText.substring(Math.max(0, startPos - startSyntax.length), startPos);
                    const afterPos = startPos + selectedText.length;
                    const afterText = lineText.substring(afterPos, afterPos + endSyntax.length);
                    
                    return beforeText === startSyntax && afterText === endSyntax;
                } else {
                    // Check if line starts with heading marker
                    if (type.startsWith('h')) {
                        return lineText.startsWith(startSyntax);
                    }
                    return false;
                }
            }       
     // Handle Enter key for list continuation
            handleEnterKey(e) {
                const currentLineElement = this.getCurrentLineElement();
                if (!currentLineElement) return;

                const currentLineText = currentLineElement.textContent || '';

                // Check if current line is a list item
                const unorderedMatch = currentLineText.match(/^(\s*)[-*+] (.*)$/);
                const orderedMatch = currentLineText.match(/^(\s*)(\d+)\. (.*)$/);

                if (unorderedMatch) {
                    e.preventDefault();
                    const indent = unorderedMatch[1];
                    const content = unorderedMatch[2];

                    if (content.trim() === '') {
                        // Empty list item - exit list mode
                        currentLineElement.textContent = '';
                    } else {
                        // Continue list
                        this.insertNewLineAfter(currentLineElement, indent + '- ');
                        
                        // FIX: Format the previous line AFTER creating new line to avoid cursor issues
                        setTimeout(() => {
                            this.forceFormatPreviousLineForLists(currentLineElement);
                        }, 10);
                    }
                } else if (orderedMatch) {
                    e.preventDefault();
                    const indent = orderedMatch[1];
                    const number = parseInt(orderedMatch[2]);
                    const content = orderedMatch[3];

                    if (content.trim() === '') {
                        // Empty list item - exit list mode
                        currentLineElement.textContent = '';
                    } else {
                        // Continue list with next number
                        this.insertNewLineAfter(currentLineElement, indent + (number + 1) + '. ');
                        
                        // FIX: Format the previous line AFTER creating new line to avoid cursor issues
                        setTimeout(() => {
                            this.forceFormatPreviousLineForLists(currentLineElement);
                        }, 10);
                    }
                } else {
                    // Regular line break - ensure it works properly
                    // If the editor isn't properly initialized, force create a new line
                    if (!this.isInitialized) {
                        e.preventDefault();
                        this.insertNewLineAfter(currentLineElement, '');
                        return;
                    }

                    // Let default behavior handle it, but ensure it works
                    // The input handler will split the line automatically
                }
            }

            // FIX: Force format current line if it's a list with formatting
            forceFormatCurrentLineForLists(lineElement) {
                if (!lineElement || !lineElement.classList.contains('editing')) return;
                
                const content = lineElement.textContent || '';
                const isUnorderedList = content.match(/^(\s*)[-*+] (.+)$/);
                const isOrderedList = content.match(/^(\s*)(\d+)\. (.+)$/);
                
                // If it's a list with bold formatting, force immediate format
                if ((isUnorderedList || isOrderedList) && content.includes('**')) {
                    // Temporarily format the line to render bold text
                    setTimeout(() => {
                        this.formatLine(lineElement);
                        // Then immediately switch back to edit mode after a brief delay
                        setTimeout(() => {
                            this.makeLineEditable(lineElement);
                        }, 50);
                    }, 10);
                }
            }

            // FIX: Format previous line after Enter without interfering with cursor
            forceFormatPreviousLineForLists(currentLineElement) {
                if (!currentLineElement) return;
                
                const content = currentLineElement.textContent || '';
                const isUnorderedList = content.match(/^(\s*)[-*+] (.+)$/);
                const isOrderedList = content.match(/^(\s*)(\d+)\. (.+)$/);
                
                // If it's a list with bold formatting, just format it (don't switch back to edit)
                if ((isUnorderedList || isOrderedList) && content.includes('**')) {
                    // Format the line to show bold text, but don't switch back to edit mode
                    this.formatLine(currentLineElement);
                }
            }

            // FIX: Apply double-render logic for lists when switching lines
            applyDoubleRenderForLists(lineElement) {
                if (!lineElement || lineElement.classList.contains('editing')) return;
                
                const rawContent = this.getLineRawContent(lineElement);
                const isUnorderedList = rawContent.match(/^(\s*)[-*+] (.+)$/);
                const isOrderedList = rawContent.match(/^(\s*)(\d+)\. (.+)$/);
                
                if ((isUnorderedList || isOrderedList) && rawContent.includes('**')) {
                    // Apply the same double-render logic used in formatLine
                    setTimeout(() => {
                        const formattedElement = this.renderer.parseLine(rawContent);
                        lineElement.innerHTML = '';
                        if (formattedElement.tagName === 'DIV') {
                            lineElement.innerHTML = formattedElement.innerHTML;
                        } else {
                            lineElement.appendChild(formattedElement);
                        }
                        
                        // Second render for consistency
                        setTimeout(() => {
                            const secondFormattedElement = this.renderer.parseLine(rawContent);
                            lineElement.innerHTML = '';
                            if (secondFormattedElement.tagName === 'DIV') {
                                lineElement.innerHTML = secondFormattedElement.innerHTML;
                            } else {
                                lineElement.appendChild(secondFormattedElement);
                            }
                        }, 25);
                    }, 10);
                }
            }

            // Detect and convert ``` ... ``` pattern into a code block
            detectAndConvertCodeBlock(lineElement) {
                if (!lineElement) return;
                
                const content = lineElement.textContent || '';
                
                // Check if this line is ```
                if (content.trim() === '```') {
                    // Look backwards for another ```
                    let startLine = null;
                    let currentLine = lineElement.previousElementSibling;
                    const linesToConvert = [];
                    
                    while (currentLine) {
                        const lineContent = currentLine.textContent || '';
                        
                        if (lineContent.trim() === '```') {
                            startLine = currentLine;
                            break;
                        }
                        
                        linesToConvert.unshift(currentLine);
                        currentLine = currentLine.previousElementSibling;
                    }
                    
                    // If we found a matching ```, convert to code block
                    if (startLine) {
                        // Collect all the code content
                        const codeLines = linesToConvert.map(line => line.textContent || '');
                        const codeContent = codeLines.join('\n');
                        
                        // Create the code block
                        const isDark = document.body.classList.contains('dark');
                        startLine.dataset.isCodeBlock = 'true';
                        startLine.contentEditable = 'false';
                        startLine.classList.remove('editing');
                        
                        const codeContainer = document.createElement('div');
                        codeContainer.className = 'code-block-container';
                        codeContainer.style.cssText = `background: ${isDark ? '#2a2a2a' : '#f5f5f5'}; border-left: 3px solid ${isDark ? '#4fc3f7' : '#007acc'}; border-radius: 4px; margin: 8px 0; overflow: hidden;`;
                        
                        const codeHeader = document.createElement('div');
                        codeHeader.className = 'code-block-header';
                        codeHeader.style.cssText = `padding: 4px 12px; background: ${isDark ? '#1f1f1f' : '#e8e8e8'}; font-family: monospace; font-size: 12px; color: ${isDark ? '#888' : '#666'}; border-bottom: 1px solid ${isDark ? '#444' : '#ddd'};`;
                        codeHeader.textContent = 'code';
                        
                        const codeArea = document.createElement('pre');
                        codeArea.contentEditable = 'true';
                        codeArea.className = 'code-block-content';
                        codeArea.style.cssText = `margin: 0; padding: 12px; font-family: monospace; white-space: pre; overflow-x: auto; outline: none; min-height: 60px; background: ${isDark ? '#2a2a2a' : '#f5f5f5'}; color: ${isDark ? '#d0d0d0' : '#3b3a3a'};`;
                        codeArea.textContent = codeContent;
                        
                        codeContainer.appendChild(codeHeader);
                        codeContainer.appendChild(codeArea);
                        
                        startLine.innerHTML = '';
                        startLine.appendChild(codeContainer);
                        
                        // Remove all the lines in between and the closing ```
                        linesToConvert.forEach(line => line.remove());
                        lineElement.remove();
                        
                        // Update line indices
                        this.updateLineIndices();
                        this.updateLineNumbersNow();
                    }
                }
            }

            // Handle Backspace key for proper line merging and deletion
            handleBackspaceKey(e) {
                const selection = window.getSelection();
                if (!selection.rangeCount) return;

                const range = selection.getRangeAt(0);
                const currentLineElement = this.getCurrentLineElement();
                if (!currentLineElement) return;

                const currentContent = this.getLineRawContent(currentLineElement);
                const cursorPos = this.getCursorPositionInLine(currentLineElement);

                // Check if we should delete the entire line
                if (currentContent.trim() === '' && cursorPos === 0) {
                    // Empty line - delete it if there are other lines
                    const allLines = this.editor.querySelectorAll('.editor-line');
                    if (allLines.length > 1) {
                        e.preventDefault();
                        this.deleteCurrentLine(currentLineElement, 'previous');
                        return;
                    } else {
                        // Only line left - don't delete, just ensure cursor is visible
                        e.preventDefault();

                        // Clear the line but keep it editable with proper cursor support
                        currentLineElement.innerHTML = '';
                        currentLineElement.textContent = '';
                        currentLineElement.classList.add('editing');

                        // Add zero-width space for cursor visibility
                        const textNode = document.createTextNode('\u200B');
                        currentLineElement.appendChild(textNode);

                        // Position cursor and focus with better error handling
                        setTimeout(() => {
                            try {
                                const range = document.createRange();
                                const selection = window.getSelection();
                                range.setStart(textNode, 0);
                                range.collapse(true);
                                selection.removeAllRanges();
                                selection.addRange(range);
                                this.editor.focus();
                            } catch (error) {
                                // Fallback: just focus the editor
                                this.editor.focus();
                            }
                        }, 0);
                        return;
                    }
                }         
       // Check if cursor is at the beginning of the line (merge with previous)
                if (cursorPos === 0) {
                    // Cursor is at the beginning of the line
                    const previousLine = currentLineElement.previousElementSibling;

                    if (previousLine && previousLine.classList.contains('editor-line')) {
                        e.preventDefault();

                        // Get content of both lines
                        const currentContent = this.getLineRawContent(currentLineElement);
                        const previousContent = this.getLineRawContent(previousLine);

                        // Merge content
                        const mergedContent = previousContent + currentContent;

                        // Update previous line with merged content
                        if (previousLine.classList.contains('editing')) {
                            previousLine.textContent = mergedContent;
                        } else {
                            // Switch previous line to edit mode and set content
                            this.makeLineEditable(previousLine);
                            previousLine.textContent = mergedContent;
                        }

                        // Position cursor at the junction point (end of previous content)
                        this.setCursorInLine(previousLine, previousContent.length);

                        // Remove current line
                        currentLineElement.remove();

                        // Update line indices
                        this.updateLineIndices();

                        // Update current editing line reference
                        this.currentEditingLineElement = previousLine;

                        // Ensure cursor remains visible after DOM changes
                        setTimeout(() => {
                            this.ensureCursorVisible();
                            this.setCursorInLine(previousLine, previousContent.length);
                        }, 0);

                        // Update line numbers immediately for rapid operations
                        this.updateLineNumbersImmediate();
                    }
                }
                // If cursor is not at beginning, let default backspace behavior handle it
            }

            // Handle Delete key for line deletion and merging
            handleDeleteKey(e) {
                const selection = window.getSelection();
                if (!selection.rangeCount) return;

                const currentLineElement = this.getCurrentLineElement();
                if (!currentLineElement) return;

                const currentContent = this.getLineRawContent(currentLineElement);
                const cursorPos = this.getCursorPositionInLine(currentLineElement);

                // Check if we should delete the entire line
                if (currentContent.trim() === '') {
                    // Empty line - delete it if there are other lines
                    const allLines = this.editor.querySelectorAll('.editor-line');
                    if (allLines.length > 1) {
                        e.preventDefault();
                        this.deleteCurrentLine(currentLineElement, 'next');
                        return;
                    }
                }

                // Check if cursor is at the end of the line (merge with next)
                if (cursorPos === currentContent.length) {
                    const nextLine = currentLineElement.nextElementSibling;

                    if (nextLine && nextLine.classList.contains('editor-line')) {
                        e.preventDefault();

                        // Get content of both lines
                        const nextContent = this.getLineRawContent(nextLine);

                        // Merge content
                        const mergedContent = currentContent + nextContent;

                        // Update current line with merged content
                        if (currentLineElement.classList.contains('editing')) {
                            currentLineElement.textContent = mergedContent;
                        } else {
                            this.makeLineEditable(currentLineElement);
                            currentLineElement.textContent = mergedContent;
                        }

                        // Position cursor at the junction point
                        this.setCursorInLineSafe(currentLineElement, currentContent.length);

                        // Remove next line
                        nextLine.remove();

                        this.updateLineIndices();
                        this.updateLineNumbersImmediate();
                    }
                }
                // If cursor is not at end, let default delete behavior handle it
            }  
          // Delete the current line and move cursor appropriately
            deleteCurrentLine(lineElement, direction = 'previous') {
                const allLines = this.editor.querySelectorAll('.editor-line');
                if (allLines.length <= 1) {
                    // Don't delete the last line, just clear it
                    lineElement.innerHTML = '';
                    lineElement.classList.add('editing');
                    const textNode = document.createTextNode('\u200B');
                    lineElement.appendChild(textNode);
                    this.setCursorInLineSafe(lineElement, 0);
                    return;
                }

                // Find target line to move cursor to
                let targetLine;
                if (direction === 'previous') {
                    targetLine = lineElement.previousElementSibling;
                    if (!targetLine) {
                        targetLine = lineElement.nextElementSibling;
                    }
                } else {
                    targetLine = lineElement.nextElementSibling;
                    if (!targetLine) {
                        targetLine = lineElement.previousElementSibling;
                    }
                }

                if (targetLine && targetLine.classList.contains('editor-line')) {
                    // Ensure target line is in edit mode
                    if (!targetLine.classList.contains('editing')) {
                        this.makeLineEditable(targetLine);
                    }

                    // Position cursor at appropriate position
                    const targetContent = targetLine.textContent || '';
                    const cursorPos = direction === 'previous' ? targetContent.length : 0;
                    this.setCursorInLineSafe(targetLine, cursorPos);

                    // Update current editing line reference
                    this.currentEditingLineElement = targetLine;

                    // Remove the line
                    lineElement.remove();

                    this.updateLineIndices();
                    this.updateLineNumbersImmediate();
                }
            }

            // Insert a new line after the current line
            insertNewLineAfter(currentLineElement, content = '') {
                const newLineDiv = document.createElement('div');
                newLineDiv.className = 'editor-line editing';

                if (content.trim() === '') {
                    // Empty line - add zero-width space for cursor visibility
                    const textNode = document.createTextNode('\u200B');
                    newLineDiv.appendChild(textNode);
                } else {
                    newLineDiv.textContent = content;
                }

                const lineIndex = parseInt(currentLineElement.dataset.lineIndex) + 1;
                newLineDiv.dataset.lineIndex = lineIndex;

                currentLineElement.parentNode.insertBefore(newLineDiv, currentLineElement.nextSibling);

                // Update line indices for subsequent lines
                this.updateLineIndices();

                this.updateLineNumbersImmediate();

                // Move cursor to new line with error handling
                if (content.trim() === '') {
                    // Position cursor in zero-width space
                    setTimeout(() => {
                        const textNode = newLineDiv.firstChild;
                        if (textNode) {
                            const range = document.createRange();
                            const selection = window.getSelection();
                            range.setStart(textNode, 0);
                            range.collapse(true);
                            selection.removeAllRanges();
                            selection.addRange(range);
                            this.editor.focus();
                        }
                    }, 0);
                } else {
                    this.setCursorInLineSafe(newLineDiv, content.length);
                }

                this.currentEditingLineElement = newLineDiv;

                // Ensure cursor remains visible after DOM changes
                setTimeout(() => {
                    this.ensureCursorVisible();
                }, 0);
            } 
           // Handle Tab key for list indentation
            handleTabKey(e) {
                const currentLineElement = this.getCurrentLineElement();
                if (!currentLineElement) return;

                const currentLineText = currentLineElement.textContent || '';
                const unorderedMatch = currentLineText.match(/^(\s*)[-*+] (.*)$/);
                const orderedMatch = currentLineText.match(/^(\s*)(\d+)\. (.*)$/);

                if (unorderedMatch || orderedMatch) {
                    e.preventDefault();

                    if (e.shiftKey) {
                        // Shift+Tab: Decrease indentation
                        this.decreaseListIndent(currentLineElement);
                    } else {
                        // Tab: Increase indentation
                        this.increaseListIndent(currentLineElement);
                    }
                }
            }

            // Increase list item indentation
            increaseListIndent(lineElement) {
                const currentText = lineElement.textContent || '';
                const cursorPos = this.getCursorPositionInLine(lineElement);

                // Add two spaces at the beginning
                lineElement.textContent = '  ' + currentText;

                // Restore cursor position
                this.setCursorInLine(lineElement, cursorPos + 2);
            }

            // Decrease list item indentation
            decreaseListIndent(lineElement) {
                const currentText = lineElement.textContent || '';
                const cursorPos = this.getCursorPositionInLine(lineElement);

                let newText = currentText;
                let adjustment = 0;

                // Remove up to two spaces from the beginning
                if (currentText.startsWith('  ')) {
                    newText = currentText.substring(2);
                    adjustment = -2;
                } else if (currentText.startsWith(' ')) {
                    newText = currentText.substring(1);
                    adjustment = -1;
                }

                if (adjustment !== 0) {
                    lineElement.textContent = newText;
                    this.setCursorInLine(lineElement, Math.max(0, cursorPos + adjustment));
                }
            }
        }   
     // ToolbarController class for managing formatting buttons
        class ToolbarController {
            constructor(editingController) {
                this.editingController = editingController;
                this.buttons = {};
                this.initializeButtons();
                this.setupEventListeners();
            }

            initializeButtons() {
                this.buttons = {
                    bold: document.getElementById('boldBtn'),
                    italic: document.getElementById('italicBtn'),
                    strikethrough: document.getElementById('strikeBtn'),
                    highlight: document.getElementById('highlightBtn'),
                    h1: document.getElementById('h1Btn'),
                    h2: document.getElementById('h2Btn'),
                    h3: document.getElementById('h3Btn'),
                    ul: document.getElementById('ulBtn'),
                    ol: document.getElementById('olBtn'),
                    hr: document.getElementById('hrBtn'),
                    code: document.getElementById('codeBtn'),
                    image: document.getElementById('imageBtn'),
                    table: document.getElementById('tableBtn')
                };
            }

            setupEventListeners() {
                // Basic formatting buttons - prevent default and use mousedown to preserve selection
                this.buttons.bold.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    // Save selection before button gets focus
                    this.savedSelection = this.saveSelection();
                    this.toggleFormatting('bold');
                });
                this.buttons.italic.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    // Save selection before button gets focus
                    this.savedSelection = this.saveSelection();
                    this.toggleFormatting('italic');
                });
                this.buttons.strikethrough.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    // Save selection before button gets focus
                    this.savedSelection = this.saveSelection();
                    this.toggleFormatting('strikethrough');
                });
                this.buttons.highlight.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    // Save selection before button gets focus
                    this.savedSelection = this.saveSelection();
                    this.toggleFormatting('highlight');
                });

                // Heading buttons
                this.buttons.h1.addEventListener('click', () => this.applyHeading('h1'));
                this.buttons.h2.addEventListener('click', () => this.applyHeading('h2'));
                this.buttons.h3.addEventListener('click', () => this.applyHeading('h3'));

                // List and rule buttons
                this.buttons.ul.addEventListener('click', () => this.insertList('ul'));
                this.buttons.ol.addEventListener('click', () => this.insertList('ol'));
                this.buttons.hr.addEventListener('click', () => this.insertHorizontalRule());

                // New buttons: Code block, Image, Table
                this.buttons.code.addEventListener('click', () => this.insertCodeBlock());
                this.buttons.image.addEventListener('click', () => this.insertImage());
                this.buttons.table.addEventListener('click', () => this.insertTable());

                // Update button states on selection change
                document.addEventListener('selectionchange', () => {
                    this.updateButtonStates();
                });

                // Update button states on editor input
                this.editingController.editor.addEventListener('input', () => {
                    setTimeout(() => this.updateButtonStates(), 10);
                });
            }

            // Save current selection state
            saveSelection() {
                const selection = window.getSelection();
                if (!selection.rangeCount) return null;

                const range = selection.getRangeAt(0);
                const selectedText = range.toString();
                
                return {
                    text: selectedText,
                    startContainer: range.startContainer,
                    startOffset: range.startOffset,
                    endContainer: range.endContainer,
                    endOffset: range.endOffset,
                    hasSelection: selectedText.length > 0
                };
            }

            // Restore saved selection
            restoreSelection(savedSelection) {
                if (!savedSelection) return false;

                try {
                    const selection = window.getSelection();
                    const range = document.createRange();
                    
                    range.setStart(savedSelection.startContainer, savedSelection.startOffset);
                    range.setEnd(savedSelection.endContainer, savedSelection.endOffset);
                    
                    selection.removeAllRanges();
                    selection.addRange(range);
                    return true;
                } catch (e) {
                    return false;
                }
            }

            toggleFormatting(type) {
                // Restore the saved selection first
                if (this.savedSelection) {
                    this.restoreSelection(this.savedSelection);
                }

                // Use the same logic as keyboard shortcuts
                const formatMap = {
                    'bold': ['**', '**'],
                    'italic': ['*', '*'],
                    'strikethrough': ['~~', '~~'],
                    'highlight': ['==', '==']
                };

                if (formatMap[type]) {
                    const [start, end] = formatMap[type];
                    this.editingController.insertMarkdownSyntax(start, end);
                }
                
                // Clear saved selection after use
                this.savedSelection = null;
                
                this.updateButtonStates();
            }

            applyHeading(level) {
                this.editingController.applyFormatting(level);
                this.updateButtonStates();
            }           
 insertList(type) {
                const currentLine = this.editingController.getCurrentLineElement();
                if (!currentLine) return;

                // Ensure line is in edit mode
                if (!currentLine.classList.contains('editing')) {
                    this.editingController.makeLineEditable(currentLine);
                }

                const prefix = type === 'ul' ? '- ' : '1. ';

                // If line is empty, just add the prefix
                if (!currentLine.textContent.trim()) {
                    currentLine.textContent = prefix;
                    // Position cursor at the end (after the prefix)
                    this.editingController.setCursorInLine(currentLine, prefix.length);
                } else {
                    // If line has content, add prefix at the beginning
                    const currentText = currentLine.textContent;
                    currentLine.textContent = prefix + currentText;
                    // Position cursor after the prefix
                    this.editingController.setCursorInLine(currentLine, prefix.length);
                }
            }

            insertHorizontalRule() {
                const currentLine = this.editingController.getCurrentLineElement();
                if (!currentLine) return;

                // Ensure line is in edit mode
                if (!currentLine.classList.contains('editing')) {
                    this.editingController.makeLineEditable(currentLine);
                }

                // Insert --- on a new line
                const newLineDiv = document.createElement('div');
                newLineDiv.className = 'editor-line editing';
                newLineDiv.textContent = '---';
                
                currentLine.parentNode.insertBefore(newLineDiv, currentLine.nextSibling);
                
                // Create another new line after the HR for typing
                const afterLineDiv = document.createElement('div');
                afterLineDiv.className = 'editor-line editing';
                afterLineDiv.textContent = '\u200B';
                
                newLineDiv.parentNode.insertBefore(afterLineDiv, newLineDiv.nextSibling);
                
                // Update line indices
                this.editingController.updateLineIndices();
                
                // Position cursor in the line after the HR
                setTimeout(() => {
                    this.editingController.setCursorInLine(afterLineDiv, 0);
                    this.editingController.currentEditingLineElement = afterLineDiv;
                }, 10);
            }



            insertCodeBlock() {
                const currentLine = this.editingController.getCurrentLineElement();
                if (!currentLine) return;

                // Ensure line is in edit mode
                if (!currentLine.classList.contains('editing')) {
                    this.editingController.makeLineEditable(currentLine);
                }

                // Create a code block as a single formatted element (like tables)
                const codeBlockLine = document.createElement('div');
                codeBlockLine.className = 'editor-line';
                codeBlockLine.dataset.isCodeBlock = 'true';
                codeBlockLine.contentEditable = 'false';
                
                // Detect dark mode
                const isDark = document.body.classList.contains('dark');
                
                // Create the code block container
                const codeContainer = document.createElement('div');
                codeContainer.className = 'code-block-container';
                codeContainer.style.cssText = `background: ${isDark ? '#2a2a2a' : '#f5f5f5'}; border-left: 3px solid ${isDark ? '#4fc3f7' : '#007acc'}; border-radius: 4px; margin: 8px 0; overflow: hidden;`;
                
                // Create the header
                const codeHeader = document.createElement('div');
                codeHeader.className = 'code-block-header';
                codeHeader.style.cssText = `padding: 4px 12px; background: ${isDark ? '#1f1f1f' : '#e8e8e8'}; font-family: monospace; font-size: 12px; color: ${isDark ? '#888' : '#666'}; border-bottom: 1px solid ${isDark ? '#444' : '#ddd'};`;
                codeHeader.textContent = 'code';
                
                // Create the editable code area
                const codeArea = document.createElement('pre');
                codeArea.contentEditable = 'true';
                codeArea.className = 'code-block-content';
                codeArea.style.cssText = `margin: 0; padding: 12px; font-family: monospace; white-space: pre; overflow-x: auto; outline: none; min-height: 60px; background: ${isDark ? '#2a2a2a' : '#f5f5f5'}; color: ${isDark ? '#d0d0d0' : '#3b3a3a'};`;
                codeArea.textContent = 'Your code here';
                
                codeContainer.appendChild(codeHeader);
                codeContainer.appendChild(codeArea);
                codeBlockLine.appendChild(codeContainer);
                
                // Insert after current line
                const afterLine = document.createElement('div');
                afterLine.className = 'editor-line editing';
                afterLine.textContent = '\u200B';
                
                currentLine.parentNode.insertBefore(codeBlockLine, currentLine.nextSibling);
                codeBlockLine.parentNode.insertBefore(afterLine, codeBlockLine.nextSibling);
                
                // Update line indices
                this.editingController.updateLineIndices();
                
                // Focus the code area
                setTimeout(() => {
                    codeArea.focus();
                    // Select all the placeholder text
                    const range = document.createRange();
                    const selection = window.getSelection();
                    range.selectNodeContents(codeArea);
                    selection.removeAllRanges();
                    selection.addRange(range);
                }, 10);
            }

            insertImage() {
                const currentLine = this.editingController.getCurrentLineElement();
                if (!currentLine) return;

                // Ensure line is in edit mode
                if (!currentLine.classList.contains('editing')) {
                    this.editingController.makeLineEditable(currentLine);
                }

                // Prompt for image URL
                const imageUrl = prompt('Enter image URL:', 'https://');
                if (!imageUrl) return;

                const altText = prompt('Enter alt text (optional):', 'Image');

                // Insert image markdown
                const imageMarkdown = `![${altText || 'Image'}](${imageUrl})`;
                
                // Insert on a new line
                const newLine = document.createElement('div');
                newLine.className = 'editor-line editing';
                newLine.textContent = imageMarkdown;
                
                currentLine.parentNode.insertBefore(newLine, currentLine.nextSibling);
                
                // Update line indices
                this.editingController.updateLineIndices();
                
                // Position cursor after the image
                setTimeout(() => {
                    this.editingController.setCursorInLine(newLine, imageMarkdown.length);
                    this.editingController.currentEditingLineElement = newLine;
                }, 10);
            }

            showTableSizeSelector(callback) {
                // Create overlay
                const overlay = document.createElement('div');
                overlay.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 10000;';
                
                // Create popup
                const popup = document.createElement('div');
                const isDark = document.body.classList.contains('dark');
                popup.style.cssText = `background: ${isDark ? '#2a2a2a' : 'white'}; padding: 20px; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);`;
                
                // Title
                const title = document.createElement('div');
                title.textContent = 'Select table size';
                title.style.cssText = `margin-bottom: 12px; font-size: 16px; font-weight: 500; color: ${isDark ? '#d0d0d0' : '#3b3a3a'};`;
                popup.appendChild(title);
                
                // Size display
                const sizeDisplay = document.createElement('div');
                sizeDisplay.textContent = '1 √ó 1';
                sizeDisplay.style.cssText = `margin-bottom: 12px; font-size: 14px; color: ${isDark ? '#888' : '#666'}; text-align: center;`;
                popup.appendChild(sizeDisplay);
                
                // Grid container
                const grid = document.createElement('div');
                grid.style.cssText = 'display: grid; grid-template-columns: repeat(20, 20px); gap: 2px; margin-bottom: 12px;';
                
                let selectedRows = 0;
                let selectedCols = 0;
                
                // Create 20x20 grid
                for (let r = 0; r < 20; r++) {
                    for (let c = 0; c < 20; c++) {
                        const cell = document.createElement('div');
                        cell.style.cssText = `width: 20px; height: 20px; border: 1px solid ${isDark ? '#555' : '#ccc'}; cursor: pointer; transition: background 0.1s;`;
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        
                        cell.addEventListener('mouseenter', () => {
                            selectedRows = r + 1;
                            selectedCols = c + 1;
                            sizeDisplay.textContent = `${selectedRows} √ó ${selectedCols}`;
                            
                            // Highlight cells
                            grid.querySelectorAll('div').forEach(gridCell => {
                                const cellRow = parseInt(gridCell.dataset.row);
                                const cellCol = parseInt(gridCell.dataset.col);
                                if (cellRow < selectedRows && cellCol < selectedCols) {
                                    gridCell.style.background = '#007acc';
                                } else {
                                    gridCell.style.background = 'transparent';
                                }
                            });
                        });
                        
                        cell.addEventListener('click', () => {
                            overlay.remove();
                            callback(selectedRows, selectedCols);
                        });
                        
                        grid.appendChild(cell);
                    }
                }
                
                popup.appendChild(grid);
                
                // Cancel button
                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = 'Cancel';
                cancelBtn.style.cssText = `width: 100%; padding: 8px; background: ${isDark ? '#333' : '#ddd'}; border: none; border-radius: 4px; cursor: pointer; color: ${isDark ? '#d0d0d0' : '#3b3a3a'};`;
                cancelBtn.onclick = () => overlay.remove();
                popup.appendChild(cancelBtn);
                
                overlay.appendChild(popup);
                document.body.appendChild(overlay);
                
                // Close on overlay click
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) overlay.remove();
                });
            }

            insertTable() {
                const currentLine = this.editingController.getCurrentLineElement();
                if (!currentLine) return;

                // Ensure line is in edit mode
                if (!currentLine.classList.contains('editing')) {
                    this.editingController.makeLineEditable(currentLine);
                }

                // Show visual table size selector
                this.showTableSizeSelector((rows, cols) => {
                    // Create table HTML with contenteditable cells (no special header styling)
                    let tableHTML = '<table style="border-collapse: collapse; width: 100%; margin: 16px 0;">';
                    
                    // All rows (no thead/tbody distinction)
                    tableHTML += '<tbody>';
                    for (let r = 0; r < rows; r++) {
                        tableHTML += '<tr>';
                        for (let c = 0; c < cols; c++) {
                            tableHTML += `<td contenteditable="true" style="border: 1px solid #ddd; padding: 8px;">Cell ${r + 1},${c + 1}</td>`;
                        }
                        tableHTML += '</tr>';
                    }
                    tableHTML += '</tbody></table>';

                    // Insert table as a formatted element
                    const tableLine = document.createElement('div');
                    tableLine.className = 'editor-line';
                    tableLine.innerHTML = tableHTML;
                    tableLine.dataset.isTable = 'true';
                    tableLine.contentEditable = 'false'; // Make the container non-editable, but cells are editable
                    
                    const afterLine = document.createElement('div');
                    afterLine.className = 'editor-line editing';
                    afterLine.textContent = '\u200B';
                    
                    currentLine.parentNode.insertBefore(tableLine, currentLine.nextSibling);
                    tableLine.parentNode.insertBefore(afterLine, tableLine.nextSibling);
                    
                    // Update line indices
                    this.editingController.updateLineIndices();
                    
                    // Position cursor after the table
                    setTimeout(() => {
                        this.editingController.setCursorInLine(afterLine, 0);
                        this.editingController.currentEditingLineElement = afterLine;
                    }, 10);
                });
            }

            updateButtonStates() {
                if (!this.editingController.isEditing()) return;

                // Update formatting button states
                Object.keys(this.buttons).forEach(type => {
                    if (['ul', 'ol', 'hr', 'code', 'image', 'table'].includes(type)) return; // Skip list, hr, and new buttons

                    const button = this.buttons[type];
                    const hasFormat = this.editingController.hasFormatting(type);

                    if (hasFormat) {
                        button.classList.add('active');
                    } else {
                        button.classList.remove('active');
                    }
                });
            }
        }

        // AutosaveManager class for handling localStorage persistence
        class AutosaveManager {
            constructor(editor, editingController, renderer) {
                this.editor = editor;
                this.editingController = editingController;
                this.renderer = renderer;
                this.storageKey = "marktext_autosave";
                this.autosaveEl = document.getElementById("autosave");
                this.saveTimeout = null;
                
                // Request persistent storage to prevent data loss
                this.requestPersistentStorage();
            }
            
            // Request persistent storage permission
            async requestPersistentStorage() {
                if (navigator.storage && navigator.storage.persist) {
                    try {
                        const isPersisted = await navigator.storage.persist();
                        if (isPersisted) {
                            console.log('Storage will persist and not be cleared automatically');
                        } else {
                            console.log('Storage may be cleared by the browser under storage pressure');
                        }
                        
                        // Check if storage is already persisted
                        if (navigator.storage.persisted) {
                            const persisted = await navigator.storage.persisted();
                            console.log('Storage persisted status:', persisted);
                        }
                    } catch (error) {
                        console.warn('Could not request persistent storage:', error);
                    }
                } else {
                    console.log('Persistent storage API not supported');
                }
            }

            // Get current content as markdown
            getCurrentContent() {
                if (this.editingController.getAllContent) {
                    return this.editingController.getAllContent();
                }
                return this.editor.textContent || '';
            }

            // Minimal content cleaning - preserve user's formatting as much as possible
            cleanContent(content) {
                if (!content) return '';

                // MINIMAL CLEANING: Only remove trailing whitespace from lines
                // Don't remove any newlines - preserve all user formatting
                let cleaned = content.split('\n').map(line => line.trimEnd()).join('\n');

                // Don't remove excessive newlines - user might want them
                // Don't trim leading/trailing empty lines - preserve user's formatting

                return cleaned;
            }  
          // Load saved content from localStorage with error handling
            loadSavedContent() {
                try {
                    const savedContent = localStorage.getItem(this.storageKey) || "";

                    // Handle the specific case where content was deleted
                    if (savedContent.trim() === "") {
                        // Clear the editor completely and force proper structure
                        this.editor.innerHTML = '';
                        this.editor.textContent = '';
                    } else if (savedContent) {
                        // Clean the content before setting it
                        const cleanedContent = this.cleanContent(savedContent);
                        this.editor.textContent = cleanedContent;

                        if (this.editingController) {
                            setTimeout(() => {
                                this.editingController.saveState();
                            }, 100);
                        }
                    }

                    // Always initialize the editor, with multiple attempts for reliability
                    const initializeWithRetry = (attempt = 1) => {
                        try {
                            if (this.editingController && this.editingController.initializeEditor) {
                                this.editingController.initializeEditor();

                                // Verify initialization worked and update line numbers
                                setTimeout(() => {
                                    const lines = this.editor.querySelectorAll('.editor-line');
                                    if (lines.length === 0) {
                                        if (attempt < 3) {
                                            initializeWithRetry(attempt + 1);
                                        }
                                    } else {
                                        // Force line number update after successful initialization
                                        this.editingController.updateLineNumbersNow();

                                        // Force re-render all lines to ensure proper formatting
                                        setTimeout(() => {
                                            this.editingController.forceRenderAllLines();

                                            // Trigger a blur/focus cycle to force formatting (same as switching windows)
                                            setTimeout(() => {
                                                this.editor.blur();
                                                setTimeout(() => {
                                                    this.editor.focus();
                                                }, 50);
                                            }, 100);
                                        }, 200);
                                    }
                                }, 100);
                            } else {
                                if (attempt < 3) {
                                    setTimeout(() => initializeWithRetry(attempt + 1), 200);
                                }
                            }
                        } catch (initError) {
                            if (attempt < 3) {
                                setTimeout(() => initializeWithRetry(attempt + 1), 300);
                            }
                        }
                    };

                    setTimeout(() => initializeWithRetry(), 200);

                } catch (error) {
                    this.showErrorIndicator('Load failed');

                    // Force initialization even if loading failed
                    setTimeout(() => {
                        if (this.editingController && this.editingController.initializeEditor) {
                            this.editingController.initializeEditor();
                        }
                    }, 300);
                }
            }

            // Schedule autosave with debouncing
            scheduleSave() {
                if (this.saveTimeout) clearTimeout(this.saveTimeout);
                this.saveTimeout = setTimeout(() => {
                    this.save();
                }, 250);
            }

            // Save current content to localStorage with error handling
            save() {
                try {
                    const content = this.getCurrentContent();
                    const cleanedContent = this.cleanContent(content);
                    localStorage.setItem(this.storageKey, cleanedContent);
                    this.showSaveIndicator();
                } catch (error) {
                    this.showErrorIndicator('Save failed');
                }
            } 
           // Show autosave indicator
            showSaveIndicator() {
                this.autosaveEl.textContent = "Autosaved ‚úî";
                this.autosaveEl.style.color = '';
                setTimeout(() => {
                    this.autosaveEl.textContent = "";
                }, 1200);
            }

            // Show error indicator
            showErrorIndicator(message) {
                this.autosaveEl.textContent = message;
                this.autosaveEl.style.color = '#ff4444';
                setTimeout(() => {
                    this.autosaveEl.textContent = "";
                    this.autosaveEl.style.color = '';
                }, 3000);
            }

            // Clear saved content
            clearSaved() {
                localStorage.removeItem(this.storageKey);
                this.editor.textContent = "";
            }

            // Export content for manual save
            exportContent() {
                return this.getCurrentContent();
            }
        }

        const editor = document.getElementById("editor");
        const lineNumbers = document.getElementById("lineNumbers");
        const status = document.getElementById("status");
        const autosaveEl = document.getElementById("autosave");
        const saveBtn = document.getElementById("saveBtn");
        // Theme button removed - use settings panel instead
        const clearBtn = document.getElementById("clearBtn");

        // Initialize all components with better error handling
        let markdownRenderer, editingController, toolbarController, autosaveManager;

        try {
            markdownRenderer = new MarkdownRenderer();
            editingController = new EditingController(editor, markdownRenderer);
            toolbarController = new ToolbarController(editingController);
            autosaveManager = new AutosaveManager(editor, editingController, markdownRenderer);

            // Set reference for autosave manager in editing controller
            editingController.autosaveManager = autosaveManager;

            // Load saved content with delay to ensure DOM is ready
            setTimeout(() => {
                autosaveManager.loadSavedContent();
            }, 100);

        } catch (error) {
            // Fallback initialization
            setTimeout(() => {
                try {
                    autosaveManager.loadSavedContent();
                } catch (e) {
                    // Silent fallback
                }
            }, 500);
        }

        // Get text content from contentEditable, preserving line breaks
        function getEditorText() {
            if (editingController && editingController.getAllContent) {
                return editingController.getAllContent();
            }
            return editor.textContent || "";
        }     
   // Compute visual line numbers accounting for collapsed content and actual line heights
        // UNIFIED SYSTEM: Uses the same logic as updateLineNumbersNow() for consistency
        function computeVisualLineNumbers(text) {
            // Delegate to the EditingController's unified system if available
            if (editingController && editingController.calculateLineNumbers) {
                return editingController.calculateLineNumbers();
            }

            // Fallback: use the same logic as updateLineNumbersNow()
            const editorLines = editor.querySelectorAll('.editor-line');
            let numbersHtml = "";
            let visibleLineCount = 0;

            for (let i = 0; i < editorLines.length; i++) {
                const line = editorLines[i];

                // Skip collapsed lines
                if (line.classList.contains('collapsed')) {
                    continue;
                }

                visibleLineCount++;

                // Check if this is a header line for spacing
                const headerElement = line.querySelector('h1, h2, h3, h4, h5, h6');

                if (headerElement) {
                    // Use EXACT same spacing logic as updateLineNumbersNow()
                    const headerTag = headerElement.tagName.toLowerCase();
                    let extraLines = 0;

                    switch (headerTag) {
                        case 'h1': extraLines = 1; break;  // H1 gets 1 extra line
                        case 'h2': extraLines = 0; break;  // H2 gets no extra lines  
                        case 'h3': extraLines = 0; break;  // H3 gets no extra lines
                        default: extraLines = 0; break;
                    }

                    // Add the main line number
                    numbersHtml += `${visibleLineCount}<br>`;

                    // Add extra spacing lines
                    for (let j = 0; j < extraLines; j++) {
                        numbersHtml += `<br>`;
                    }
                } else {
                    // Regular line, just add the number
                    numbersHtml += `${visibleLineCount}<br>`;
                }
            }

            return {
                html: numbersHtml || "1<br>",
                total: Math.max(1, visibleLineCount)
            };
        }

        // Update the line numbers column and status counters
        // NOTE: This global updateAll function is now only used for:
        // - Window resize events
        // - Manual calls from console
        // - Initial setup
        // Regular input events are handled by EditingController.updateLineNumbersNow() 
        // to prevent double rendering and improve performance
        let updateId = 0;
        function updateAll() {
            // Use smart line number system
            const text = getEditorText();
            const res = computeVisualLineNumbers(text);
            // Handle both old and new HTML structures
            const fallbackHtml = res.html || '<div class="line-number" style="top: 0px;">1</div>';
            lineNumbers.innerHTML = fallbackHtml;
            updateStatus(text, res.total);
        }

        // small debounce wrapper for resize events
        let resizeTimeout = null;
        function debouncedUpdateAll(delay = 120) {
            if (resizeTimeout) clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(updateAll, delay);
        }       
 // Update word/char/line counters
        function updateStatus(text, visualLineCount) {
            // Get clean text content for accurate counting
            const cleanText = getCleanTextForCounting(text);
            const chars = cleanText.length;
            const words = cleanText.trim() ? cleanText.trim().split(/\s+/).length : 0;
            const lines = visualLineCount != null ? visualLineCount : (cleanText.split("\n").length);
            status.textContent = `Words: ${words} | Characters: ${chars} | Lines: ${lines}`;
        }

        // Get clean text content for word/character counting (removes markdown syntax)
        function getCleanTextForCounting(text) {
            if (!text) return '';

            // Remove markdown syntax for more accurate word/character counts
            let cleanText = text
                .replace(/\*\*(.*?)\*\*/g, '$1')  // Bold
                .replace(/\*(.*?)\*/g, '$1')      // Italic
                .replace(/~~(.*?)~~/g, '$1')      // Strikethrough
                .replace(/==(.*?)==/g, '$1')      // Highlight
                .replace(/^#{1,3}\s+/gm, '')      // Headings
                .replace(/^(\s*)[-*+]\s+/gm, '$1') // Unordered lists
                .replace(/^(\s*)\d+\.\s+/gm, '$1') // Ordered lists
                .replace(/^(---|\*\*\*|___)$/gm, '') // Horizontal rules
                .replace(/^\s*$/gm, '');          // Empty lines

            return cleanText;
        }

        // Optimized input handler for rapid operations
        let inputTimeout = null;
        let lastInputTime = 0;
        let rapidInputCount = 0;

        editor.addEventListener("input", () => {
            const currentTime = Date.now();
            const timeSinceLastInput = currentTime - lastInputTime;

            // Detect rapid input (less than 50ms between inputs)
            if (timeSinceLastInput < 50) {
                rapidInputCount++;
            } else {
                rapidInputCount = 0;
            }

            lastInputTime = currentTime;

            // Immediate update for responsiveness
            if (autosaveManager) {
                autosaveManager.scheduleSave();
            }

            // DISABLED: Global updateAll to prevent double rendering
            // The EditingController now handles line number updates more efficiently
        });

        // On font load, window resize or orientation change recompute
        window.addEventListener("resize", () => debouncedUpdateAll(120));
        window.addEventListener("orientationchange", () => debouncedUpdateAll(120));

        // Add scroll event listener for line number updates
        editor.addEventListener("scroll", () => {
            if (editingController && editingController.updateLineNumbersNow) {
                editingController.updateLineNumbersNow();
            }
        });

        // Add periodic line number and minimap updates
        // Moved to after initialization to avoid accessing minimapManager before it's created
        
        // Buttons
        const copyAllBtn = document.getElementById("copyAllBtn");
        
        // Only add event listener if button exists
        if (copyAllBtn) {
            copyAllBtn.addEventListener("click", async () => {
            try {
                // Get the raw markdown content
                const content = autosaveManager ? autosaveManager.exportContent() : getEditorText();
                
                // Copy to clipboard using the Clipboard API
                await navigator.clipboard.writeText(content);
                
                // Show success feedback
                const originalText = copyAllBtn.textContent;
                copyAllBtn.textContent = "Copied! ‚úì";
                copyAllBtn.style.background = "#4CAF50";
                copyAllBtn.style.color = "white";
                
                setTimeout(() => {
                    copyAllBtn.textContent = originalText;
                    copyAllBtn.style.background = "";
                    copyAllBtn.style.color = "";
                }, 1500);
            } catch (err) {
                // Fallback for older browsers
                try {
                    const content = autosaveManager ? autosaveManager.exportContent() : getEditorText();
                    const textarea = document.createElement("textarea");
                    textarea.value = content;
                    textarea.style.position = "fixed";
                    textarea.style.opacity = "0";
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand("copy");
                    document.body.removeChild(textarea);
                    
                    // Show success feedback
                    const originalText = copyAllBtn.textContent;
                    copyAllBtn.textContent = "Copied! ‚úì";
                    copyAllBtn.style.background = "#4CAF50";
                    copyAllBtn.style.color = "white";
                    
                    setTimeout(() => {
                        copyAllBtn.textContent = originalText;
                        copyAllBtn.style.background = "";
                        copyAllBtn.style.color = "";
                    }, 1500);
                } catch (fallbackErr) {
                    // Show error feedback
                    const originalText = copyAllBtn.textContent;
                    copyAllBtn.textContent = "Failed ‚úó";
                    copyAllBtn.style.background = "#f44336";
                    copyAllBtn.style.color = "white";
                    
                    setTimeout(() => {
                        copyAllBtn.textContent = originalText;
                        copyAllBtn.style.background = "";
                        copyAllBtn.style.color = "";
                    }, 1500);
                }
            }
            });
        }

        saveBtn.addEventListener("click", () => {
            const content = autosaveManager ? autosaveManager.exportContent() : getEditorText();
            const blob = new Blob([content], { type: "text/markdown" });
            const a = document.createElement("a");
            a.href = URL.createObjectURL(blob);
            a.download = "notes.md";
            a.click();
        });

        // Theme button removed - use settings panel instead

        // Global function to force complete re-initialization
        window.forceEditorReinitialize = function () {
            if (editingController) {
                editingController.forceReinitialize();
            }
        };

        // Global function to force re-render all lines
        window.forceRenderAllLines = function () {
            if (editingController) {
                editingController.forceRenderAllLines();
            }
        };

        // Global function to test rendering (for debugging)
        window.testRendering = function () {
            const lines = editor.querySelectorAll('.editor-line');

            lines.forEach((line, i) => {
                const content = line.textContent || '';

                // Test if this line should be a list
                if (content.match(/^(\s*)[-*+] (.+)$/)) {
                    // Debug logging removed for cleaner code
                }
            });

            // Force re-render
            if (editingController) {
                editingController.forceRenderAllLines();
            }
        };

        // Global function to test what's in localStorage
        window.debugStorage = function () {
            const saved = localStorage.getItem('marktext_v7_autosave');

            if (saved) {
                const lines = saved.split('\n');
                lines.forEach((line, i) => {
                    // Debug logging removed for cleaner code
                });
            }
        };

        // Global function to manually test the rendering pipeline
        window.testPipeline = function (testContent) {
            const content = testContent || '- **bold** text\n1. *italic* item';

            // Test the markdown renderer directly
            const renderer = new MarkdownRenderer();
            const lines = content.split('\n');
            lines.forEach((line, i) => {
                const result = renderer.parseLine(line);
                // Debug logging removed for cleaner code
            });
        };

        // Global debug function
        window.debugEditor = function () {
            if (editingController) {
                editingController.debugEditorState();
            }
        };  
      // Global function to explain line number calculation
        window.explainLineNumbers = function () {
            if (editingController && editingController.calculateLineNumbers) {
                const result = editingController.calculateLineNumbers();
                // Debug logging removed for cleaner code
            } else {
                const editor = document.getElementById('editor');
                const lines = editor.querySelectorAll('.editor-line');

                let visibleCount = 0;
                let collapsedCount = 0;

                lines.forEach((line, index) => {
                    const isCollapsed = line.classList.contains('collapsed');
                    const content = line.textContent.substring(0, 30) + (line.textContent.length > 30 ? '...' : '');

                    if (isCollapsed) {
                        collapsedCount++;
                    } else {
                        visibleCount++;
                    }
                });
            }
        };

        // Global function to force line number recalculation and show debug info
        window.debugLineNumbers = function () {
            // Force both systems to recalculate
            if (editingController && editingController.updateLineNumbersNow) {
                editingController.updateLineNumbersNow();
            }

            updateAll();

            // Show current state
            const lineNumbers = document.getElementById('lineNumbers');
            const status = document.getElementById('status');

            // Explain the calculation
            window.explainLineNumbers();
        };

        // Settings Manager
        class SettingsManager {
            constructor() {
                this.settingsKey = 'marktext_settings';
                this.settings = this.loadSettings();
                this.initializeUI();
                this.applySettings();
            }

            loadSettings() {
                try {
                    const saved = localStorage.getItem(this.settingsKey);
                    return saved ? JSON.parse(saved) : this.getDefaultSettings();
                } catch (e) {
                    return this.getDefaultSettings();
                }
            }

            getDefaultSettings() {
                return {
                    theme: 'light',
                    font: "'Roboto Mono'",
                    align: 'left',
                    leftMargin: 5, // In percentage
                    rightMargin: 5, // In percentage
                    showLineNumbers: true,
                    showMinimap: true,
                    showStatusBar: true
                };
            }

            saveSettings() {
                try {
                    localStorage.setItem(this.settingsKey, JSON.stringify(this.settings));
                } catch (e) {
                    console.error('Failed to save settings');
                }
            }

            initializeUI() {
                const settingsBtn = document.getElementById('settingsBtn');
                const settingsOverlay = document.getElementById('settingsOverlay');
                const settingsClose = document.getElementById('settingsClose');

                settingsBtn.addEventListener('click', () => {
                    settingsOverlay.classList.add('active');
                    this.updateUIFromSettings();
                });

                settingsClose.addEventListener('click', () => {
                    settingsOverlay.classList.remove('active');
                });

                settingsOverlay.addEventListener('click', (e) => {
                    if (e.target === settingsOverlay) {
                        settingsOverlay.classList.remove('active');
                    }
                });

                // Theme toggle
                document.getElementById('settingTheme').addEventListener('change', (e) => {
                    this.settings.theme = e.target.checked ? 'dark' : 'light';
                    this.applySettings();
                    this.saveSettings();
                });

                // Font selector
                document.getElementById('settingFont').addEventListener('change', (e) => {
                    this.settings.font = e.target.value;
                    this.applySettings();
                    this.saveSettings();
                });

                // Alignment
                document.getElementById('settingAlign').addEventListener('change', (e) => {
                    this.settings.align = e.target.value;
                    this.applySettings();
                    this.saveSettings();
                });

                // Left margin (percentage slider)
                document.getElementById('settingLeftMargin').addEventListener('input', (e) => {
                    this.settings.leftMargin = Math.max(1, parseInt(e.target.value) || 5);
                    document.getElementById('leftMarginValue').textContent = this.settings.leftMargin + '%';
                    this.applySettings();
                    this.saveSettings();
                });
                
                // Right margin (percentage slider)
                document.getElementById('settingRightMargin').addEventListener('input', (e) => {
                    this.settings.rightMargin = Math.max(1, parseInt(e.target.value) || 5);
                    document.getElementById('rightMarginValue').textContent = this.settings.rightMargin + '%';
                    this.applySettings();
                    this.saveSettings();
                });

                // Line numbers toggle
                document.getElementById('settingLineNumbers').addEventListener('change', (e) => {
                    this.settings.showLineNumbers = e.target.checked;
                    this.applySettings();
                    this.saveSettings();
                });

                // Minimap toggle
                document.getElementById('settingMinimap').addEventListener('change', (e) => {
                    this.settings.showMinimap = e.target.checked;
                    this.applySettings();
                    this.saveSettings();
                    if (minimapManager) {
                        if (e.target.checked) {
                            minimapManager.update();
                        }
                    }
                });

                // Status bar toggle
                document.getElementById('settingStatusBar').addEventListener('change', (e) => {
                    this.settings.showStatusBar = e.target.checked;
                    this.applySettings();
                    this.saveSettings();
                });
            }

            updateUIFromSettings() {
                document.getElementById('settingTheme').checked = this.settings.theme === 'dark';
                document.getElementById('settingFont').value = this.settings.font;
                document.getElementById('settingAlign').value = this.settings.align;
                document.getElementById('settingLeftMargin').value = this.settings.leftMargin;
                document.getElementById('leftMarginValue').textContent = this.settings.leftMargin + '%';
                document.getElementById('settingRightMargin').value = this.settings.rightMargin;
                document.getElementById('rightMarginValue').textContent = this.settings.rightMargin + '%';
                document.getElementById('settingLineNumbers').checked = this.settings.showLineNumbers;
                document.getElementById('settingMinimap').checked = this.settings.showMinimap;
                document.getElementById('settingStatusBar').checked = this.settings.showStatusBar;
            }

            applySettings() {
                // Theme
                document.body.className = this.settings.theme;

                // Font
                document.documentElement.style.setProperty('--editor-font', this.settings.font);

                // Alignment
                if (this.settings.align === 'center') {
                    document.documentElement.style.setProperty('--editor-align', 'center');
                    document.documentElement.style.setProperty('--editor-max-width', '800px');
                    document.documentElement.style.setProperty('--editor-margin', '0 auto');
                } else {
                    document.documentElement.style.setProperty('--editor-align', 'left');
                    document.documentElement.style.setProperty('--editor-max-width', 'none');
                    document.documentElement.style.setProperty('--editor-margin', '0');
                }

                // Left margin (percentage)
                document.documentElement.style.setProperty('--editor-left-margin', this.settings.leftMargin + '%');
                
                // Right margin (percentage)
                document.documentElement.style.setProperty('--editor-right-margin', this.settings.rightMargin + '%');

                // Line numbers
                document.documentElement.style.setProperty('--line-numbers-display', 
                    this.settings.showLineNumbers ? 'block' : 'none');

                // Minimap
                document.documentElement.style.setProperty('--minimap-display', 
                    this.settings.showMinimap ? 'block' : 'none');

                // Status bar and minimap bottom padding
                document.documentElement.style.setProperty('--statusbar-display', 
                    this.settings.showStatusBar ? 'flex' : 'none');
                
                // Adjust minimap bottom padding based on status bar visibility
                document.documentElement.style.setProperty('--minimap-bottom-padding', 
                    this.settings.showStatusBar ? '60px' : '8px');
            }
        }

        // Minimap Manager
        class MinimapManager {
            constructor(editor, editingController) {
                this.editor = editor;
                this.editingController = editingController;
                this.minimap = document.getElementById('minimap');
                this.minimapContent = document.getElementById('minimapContent');
                this.minimapViewport = document.getElementById('minimapViewport');
                this.updateTimeout = null;
                this.setupEventListeners();
            }

            setupEventListeners() {
                // Update minimap on editor changes
                this.editor.addEventListener('input', () => {
                    this.scheduleUpdate();
                });

                this.editor.addEventListener('scroll', () => {
                    this.updateViewport();
                    this.syncMinimapScroll();
                });

                // Click on minimap to scroll
                this.minimap.addEventListener('click', (e) => {
                    const rect = this.minimap.getBoundingClientRect();
                    const clickY = e.clientY - rect.top;
                    const scrollRatio = clickY / rect.height;
                    const maxScroll = this.editor.scrollHeight - this.editor.clientHeight;
                    this.editor.scrollTop = scrollRatio * maxScroll;
                });

                // 2x faster scrolling on minimap
                this.minimap.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    // Scroll editor 2x faster when scrolling over minimap
                    this.editor.scrollTop += e.deltaY * 2;
                }, { passive: false });
            }
            
            syncMinimapScroll() {
                // Skip if minimap is hidden
                if (this.minimap.style.display === 'none' || 
                    getComputedStyle(this.minimap).display === 'none') {
                    return;
                }
                
                // Sync minimap scroll position with editor
                const editorScrollRatio = this.editor.scrollTop / (this.editor.scrollHeight - this.editor.clientHeight);
                const minimapMaxScroll = this.minimap.scrollHeight - this.minimap.clientHeight;
                
                if (minimapMaxScroll > 0 && !isNaN(editorScrollRatio)) {
                    this.minimap.scrollTop = editorScrollRatio * minimapMaxScroll;
                }
            }

            scheduleUpdate() {
                if (this.updateTimeout) clearTimeout(this.updateTimeout);
                this.updateTimeout = setTimeout(() => this.update(), 500);
            }

            update() {
                try {
                    // Skip update if minimap is hidden (performance optimization)
                    if (this.minimap.style.display === 'none' || 
                        getComputedStyle(this.minimap).display === 'none') {
                        return;
                    }
                    
                    // Get the actual rendered content from editor
                    const lines = this.editor.querySelectorAll('.editor-line');
                    const totalLines = lines.length;
                    
                    if (totalLines === 0) return;
                    
                    // Find the current editing line
                    const currentLine = this.editingController?.currentEditingLineElement;
                    
                    let minimapHTML = '';
                    let lineCount = 0;
                    
                    // Build minimap content from all lines with proper formatting
                    lines.forEach((line, index) => {
                        if (line.classList.contains('collapsed')) return;
                        
                        // Limit to 500 lines for performance
                        if (lineCount > 500) return;
                        lineCount++;
                        
                        // Check if this is the current line
                        const isCurrentLine = line === currentLine || line.classList.contains('editing');
                        const currentClass = isCurrentLine ? ' minimap-current-line' : '';
                        
                        // Check for special elements: tables, code blocks, images
                        if (line.dataset.isTable === 'true') {
                            // Render actual table (scaled down)
                            const table = line.querySelector('table');
                            if (table) {
                                const tableHTML = table.outerHTML.replace(/style="[^"]*"/g, 'style="border: 0.5px solid #999; padding: 1px; font-size: 2px;"');
                                minimapHTML += `<div class="${currentClass.trim()}" style="padding: 3px; margin: 2px 0; transform: scale(0.8); transform-origin: left top;">${tableHTML}</div>`;
                            } else {
                                minimapHTML += `<div class="${currentClass.trim()}" style="padding: 4px; font-size: 5px; font-weight: bold; margin: 2px 0;">‚äû TABLE</div>`;
                            }
                        } else if (line.dataset.isCodeBlock === 'true') {
                            // Render actual code block (scaled down)
                            const codeArea = line.querySelector('.code-block-content');
                            if (codeArea) {
                                const codeText = codeArea.textContent.substring(0, 100);
                                minimapHTML += `<div class="${currentClass.trim()}" style="background: rgba(100, 100, 100, 0.2); padding: 3px; border-left: 2px solid #666; font-family: monospace; font-size: 3px; line-height: 1.2; margin: 2px 0; white-space: pre-wrap;">${this.escapeHtml(codeText)}</div>`;
                            } else {
                                minimapHTML += `<div class="${currentClass.trim()}" style="padding: 4px; font-size: 5px; font-weight: bold; margin: 2px 0;">&lt;/&gt; CODE</div>`;
                            }
                        } else if (line.querySelector('img')) {
                            // Render actual image (scaled down)
                            const img = line.querySelector('img');
                            const src = img.getAttribute('src');
                            const alt = img.getAttribute('alt') || 'Image';
                            minimapHTML += `<div class="${currentClass.trim()}" style="padding: 3px; margin: 2px 0;"><img src="${src}" alt="${this.escapeHtml(alt)}" style="max-width: 100%; height: auto; max-height: 20px; display: block; opacity: 0.8;" /></div>`;
                        } else {
                            // Check if this is a heading
                            const headingElement = line.querySelector('h1, h2, h3, h4, h5, h6');
                            if (headingElement) {
                                const level = headingElement.tagName.toLowerCase();
                                const text = headingElement.textContent || '';
                                const truncated = text.length > 120 ? text.substring(0, 120) + '...' : text;
                                
                                // Add visual distinction for headers with special class
                                const weight = level === 'h1' ? 'bold' : level === 'h2' ? '600' : 'normal';
                                minimapHTML += `<div class="minimap-header${currentClass}" style="font-weight: ${weight};">${this.escapeHtml(truncated)}</div>`;
                            } else {
                                // Check for highlights
                                const markElement = line.querySelector('mark');
                                if (markElement) {
                                    // Render with highlight
                                    const html = this.renderLineWithFormatting(line);
                                    minimapHTML += `<div class="${currentClass.trim()}">${html}</div>`;
                                } else {
                                    const text = line.textContent || '';
                                    const truncated = text.length > 150 ? text.substring(0, 150) + '...' : text;
                                    minimapHTML += `<div class="${currentClass.trim()}">${this.escapeHtml(truncated)}</div>`;
                                }
                            }
                        }
                    });
                    
                    this.minimapContent.innerHTML = minimapHTML;
                    this.updateViewport();
                } catch (error) {
                    console.error('Minimap update error:', error);
                }
            }
            
            renderLineWithFormatting(line) {
                // Render line with highlights preserved
                let html = '';
                const walker = document.createTreeWalker(
                    line,
                    NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT,
                    null,
                    false
                );
                
                let node;
                while (node = walker.nextNode()) {
                    if (node.nodeType === Node.TEXT_NODE) {
                        html += this.escapeHtml(node.textContent);
                    } else if (node.nodeType === Node.ELEMENT_NODE && node.tagName === 'MARK') {
                        html += '<mark>' + this.escapeHtml(node.textContent) + '</mark>';
                    }
                }
                
                return html;
            }
            
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            updateViewport() {
                try {
                    // Skip if minimap is hidden
                    if (this.minimap.style.display === 'none' || 
                        getComputedStyle(this.minimap).display === 'none') {
                        return;
                    }
                    
                    const editorHeight = this.editor.clientHeight;
                    const editorScrollHeight = this.editor.scrollHeight;
                    const editorScrollTop = this.editor.scrollTop;
                    
                    if (editorScrollHeight === 0) return;
                    
                    const minimapRect = this.minimap.getBoundingClientRect();
                    const minimapHeight = minimapRect.height;
                    
                    // Get actual editor lines to calculate accurate positions
                    const editorLines = this.editor.querySelectorAll('.editor-line');
                    const minimapLines = this.minimapContent.querySelectorAll('div');
                    
                    if (editorLines.length === 0 || minimapLines.length === 0) return;
                    
                    // Find which editor line is at the top of the viewport
                    const editorRect = this.editor.getBoundingClientRect();
                    let topLineIndex = 0;
                    let bottomLineIndex = 0;
                    
                    for (let i = 0; i < editorLines.length; i++) {
                        const line = editorLines[i];
                        if (line.classList.contains('collapsed')) continue;
                        
                        const lineRect = line.getBoundingClientRect();
                        const lineTop = lineRect.top - editorRect.top + editorScrollTop;
                        const lineBottom = lineRect.bottom - editorRect.top + editorScrollTop;
                        
                        if (lineTop <= editorScrollTop && lineBottom > editorScrollTop) {
                            topLineIndex = i;
                        }
                        if (lineTop <= editorScrollTop + editorHeight) {
                            bottomLineIndex = i;
                        }
                    }
                    
                    // Calculate minimap positions based on line indices
                    const minimapContentRect = this.minimapContent.getBoundingClientRect();
                    const minimapScrollTop = this.minimap.scrollTop;
                    
                    // Get the corresponding minimap line positions
                    let minimapTopPos = 0;
                    let minimapBottomPos = 0;
                    
                    if (minimapLines[topLineIndex]) {
                        const topMinimapLine = minimapLines[topLineIndex];
                        minimapTopPos = topMinimapLine.offsetTop;
                    }
                    
                    if (minimapLines[bottomLineIndex]) {
                        const bottomMinimapLine = minimapLines[bottomLineIndex];
                        minimapBottomPos = bottomMinimapLine.offsetTop + bottomMinimapLine.offsetHeight;
                    }
                    
                    // Calculate viewport height and position
                    const viewportHeight = Math.max(20, minimapBottomPos - minimapTopPos);
                    const relativeTop = minimapTopPos - minimapScrollTop;
                    
                    // Position fixed relative to viewport
                    this.minimapViewport.style.height = Math.min(viewportHeight, minimapHeight) + 'px';
                    this.minimapViewport.style.top = (minimapRect.top + Math.max(0, Math.min(minimapHeight - viewportHeight, relativeTop))) + 'px';
                    this.minimapViewport.style.left = (minimapRect.left + 4) + 'px';
                    this.minimapViewport.style.width = (minimapRect.width - 8) + 'px';
                } catch (error) {
                    console.error('Viewport update error:', error);
                }
            }
        }
        
        // Three-Mode Manager: Source, Edit, View
        class ModeManager {
            constructor(editor, editingController) {
                this.editor = editor;
                this.editingController = editingController;
                this.storageKey = 'marktext_mode';
                this.modeSelector = document.getElementById('modeSelector');
                
                // Load saved state: 'source', 'edit', or 'view'
                this.currentMode = this.loadState();
                
                this.setupEventListeners();
                
                // Apply saved state
                setTimeout(() => {
                    this.modeSelector.value = this.currentMode;
                    this.applyMode(this.currentMode);
                }, 100);
            }
            
            loadState() {
                try {
                    const saved = localStorage.getItem(this.storageKey);
                    return saved || 'edit'; // Default to edit mode
                } catch (e) {
                    return 'edit';
                }
            }
            
            saveState() {
                try {
                    localStorage.setItem(this.storageKey, this.currentMode);
                } catch (e) {
                    console.error('Failed to save mode state');
                }
            }
            
            setupEventListeners() {
                // Dropdown change
                this.modeSelector.addEventListener('change', (e) => {
                    this.setMode(e.target.value);
                });
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        if (e.key === 'u') {
                            e.preventDefault();
                            this.setMode('source');
                            this.modeSelector.value = 'source';
                        } else if (e.key === 'e') {
                            e.preventDefault();
                            // Cycle through modes
                            const modes = ['edit', 'view', 'source'];
                            const currentIndex = modes.indexOf(this.currentMode);
                            const nextMode = modes[(currentIndex + 1) % modes.length];
                            this.setMode(nextMode);
                            this.modeSelector.value = nextMode;
                        }
                    }
                });
            }
            
            setMode(mode) {
                this.currentMode = mode;
                this.saveState();
                this.applyMode(mode);
            }
            
            applyMode(mode) {
                // Reset all
                document.body.classList.remove('view-mode', 'source-mode', 'edit-mode');
                
                switch(mode) {
                    case 'source':
                        this.applySourceMode();
                        break;
                    case 'view':
                        this.applyViewMode();
                        break;
                    case 'edit':
                    default:
                        this.applyEditMode();
                        break;
                }
            }
            
            applySourceMode() {
                document.body.classList.add('source-mode');
                
                // Clean up view mode enforcement
                this.cleanupViewMode();
                
                // Save scroll position before conversion
                const scrollTop = this.editor.scrollTop;
                
                this.editor.setAttribute('contenteditable', 'true');
                
                // Make ALL lines editable (show raw markdown) - including inline formatting
                if (this.editingController) {
                    const lines = Array.from(this.editor.querySelectorAll('.editor-line'));
                    
                    // Process lines in reverse to handle code block expansion properly
                    for (let i = lines.length - 1; i >= 0; i--) {
                        const line = lines[i];
                        
                        // Convert code blocks to ``` syntax
                        if (line.dataset.isCodeBlock === 'true') {
                            const codeArea = line.querySelector('.code-block-content');
                            if (codeArea) {
                                const codeContent = codeArea.textContent || '';
                                const codeLines = codeContent.split('\n');
                                
                                // Create opening ```
                                const openLine = document.createElement('div');
                                openLine.className = 'editor-line editing';
                                openLine.textContent = '```';
                                
                                // Create content lines
                                const contentLines = codeLines.map(codeLine => {
                                    const div = document.createElement('div');
                                    div.className = 'editor-line editing';
                                    div.textContent = codeLine;
                                    return div;
                                });
                                
                                // Create closing ```
                                const closeLine = document.createElement('div');
                                closeLine.className = 'editor-line editing';
                                closeLine.textContent = '```';
                                
                                // Replace the code block with raw lines
                                line.parentNode.insertBefore(openLine, line);
                                contentLines.forEach(contentLine => {
                                    line.parentNode.insertBefore(contentLine, line);
                                });
                                line.parentNode.insertBefore(closeLine, line);
                                line.remove();
                            }
                        } else {
                            // Force conversion even if already in editing mode
                            line.classList.remove('editing');
                            this.editingController.makeLineEditable(line);
                        }
                    }
                    
                    // Update line indices after all conversions
                    this.editingController.updateLineIndices();
                    
                    // Update line numbers after conversion
                    setTimeout(() => {
                        this.editingController.updateLineNumbersNow();
                        
                        // Restore scroll position after conversion
                        this.editor.scrollTop = scrollTop;
                    }, 50);
                }
                
                this.editor.focus();
            }
            
            cleanupViewMode() {
                // Disconnect observer and clear interval
                if (this.viewModeObserver) {
                    this.viewModeObserver.disconnect();
                    this.viewModeObserver = null;
                }
                if (this.viewModeInterval) {
                    clearInterval(this.viewModeInterval);
                    this.viewModeInterval = null;
                }
            }
            
            applyViewMode() {
                document.body.classList.add('view-mode');
                
                // Save scroll position before conversion
                const scrollTop = this.editor.scrollTop;
                
                this.editor.setAttribute('contenteditable', 'false');
                
                // Convert ``` code blocks back to formatted blocks
                if (this.editingController) {
                    this.convertBackticksToCodeBlocks();
                    this.editingController.formatAllLines();
                    
                    // Restore scroll position after formatting
                    setTimeout(() => {
                        this.editor.scrollTop = scrollTop;
                    }, 10);
                }
                
                // Continuously enforce view mode
                this.enforceViewMode();
            }
            
            enforceViewMode() {
                // Use MutationObserver to watch for any changes to contenteditable
                if (this.viewModeObserver) {
                    this.viewModeObserver.disconnect();
                }
                
                this.viewModeObserver = new MutationObserver(() => {
                    if (this.currentMode === 'view' && this.editor.getAttribute('contenteditable') !== 'false') {
                        this.editor.setAttribute('contenteditable', 'false');
                    }
                });
                
                this.viewModeObserver.observe(this.editor, {
                    attributes: true,
                    attributeFilter: ['contenteditable']
                });
                
                // Also check periodically (backup)
                if (this.viewModeInterval) {
                    clearInterval(this.viewModeInterval);
                }
                
                this.viewModeInterval = setInterval(() => {
                    if (this.currentMode === 'view' && this.editor.getAttribute('contenteditable') !== 'false') {
                        this.editor.setAttribute('contenteditable', 'false');
                    }
                }, 100);
            }
            
            applyEditMode() {
                document.body.classList.add('edit-mode');
                
                // Clean up view mode enforcement
                this.cleanupViewMode();
                
                // Save scroll position before conversion
                const scrollTop = this.editor.scrollTop;
                
                this.editor.setAttribute('contenteditable', 'true');
                
                // Convert ``` code blocks back to formatted blocks
                if (this.editingController) {
                    this.convertBackticksToCodeBlocks();
                    
                    // Force format all lines to ensure rendering happens immediately
                    setTimeout(() => {
                        this.editingController.formatAllLines();
                        
                        // Restore scroll position after formatting
                        setTimeout(() => {
                            this.editor.scrollTop = scrollTop;
                        }, 10);
                    }, 10);
                }
                
                // Normal line-by-line editing (current line editable, others formatted)
                // This is the default behavior
                
                this.editor.focus();
            }
            
            convertBackticksToCodeBlocks() {
                const lines = Array.from(this.editor.querySelectorAll('.editor-line'));
                let i = 0;
                
                while (i < lines.length) {
                    const line = lines[i];
                    const content = (line.textContent || '').trim();
                    
                    // Check if this is an opening ```
                    if (content === '```' || content.startsWith('```')) {
                        const startIndex = i;
                        let endIndex = -1;
                        let codeContent = [];
                        
                        // Find the closing ```
                        for (let j = i + 1; j < lines.length; j++) {
                            const checkLine = lines[j];
                            const checkContent = (checkLine.textContent || '').trim();
                            
                            if (checkContent === '```') {
                                endIndex = j;
                                break;
                            } else {
                                codeContent.push(checkLine.textContent || '');
                            }
                        }
                        
                        // If we found a closing ```, convert to code block
                        if (endIndex !== -1) {
                            const isDark = document.body.classList.contains('dark');
                            
                            // Create code block element
                            const codeBlockLine = document.createElement('div');
                            codeBlockLine.className = 'editor-line';
                            codeBlockLine.dataset.isCodeBlock = 'true';
                            codeBlockLine.contentEditable = 'false';
                            
                            const codeContainer = document.createElement('div');
                            codeContainer.className = 'code-block-container';
                            codeContainer.style.cssText = `background: ${isDark ? '#2a2a2a' : '#f5f5f5'}; border-left: 3px solid ${isDark ? '#4fc3f7' : '#007acc'}; border-radius: 4px; margin: 8px 0; overflow: hidden;`;
                            
                            const codeHeader = document.createElement('div');
                            codeHeader.className = 'code-block-header';
                            codeHeader.style.cssText = `padding: 4px 12px; background: ${isDark ? '#1f1f1f' : '#e8e8e8'}; font-family: monospace; font-size: 12px; color: ${isDark ? '#888' : '#666'}; border-bottom: 1px solid ${isDark ? '#444' : '#ddd'};`;
                            codeHeader.textContent = 'code';
                            
                            const codeArea = document.createElement('pre');
                            codeArea.contentEditable = 'true';
                            codeArea.className = 'code-block-content';
                            codeArea.style.cssText = `margin: 0; padding: 12px; font-family: monospace; white-space: pre; overflow-x: auto; outline: none; min-height: 60px; background: ${isDark ? '#2a2a2a' : '#f5f5f5'}; color: ${isDark ? '#d0d0d0' : '#3b3a3a'};`;
                            codeArea.textContent = codeContent.join('\n');
                            
                            codeContainer.appendChild(codeHeader);
                            codeContainer.appendChild(codeArea);
                            codeBlockLine.appendChild(codeContainer);
                            
                            // Replace all the lines (opening, content, closing) with the code block
                            const firstLine = lines[startIndex];
                            firstLine.parentNode.insertBefore(codeBlockLine, firstLine);
                            
                            // Remove all the old lines
                            for (let j = startIndex; j <= endIndex; j++) {
                                if (lines[j] && lines[j].parentNode) {
                                    lines[j].remove();
                                }
                            }
                            
                            // Update the lines array and continue from the code block
                            const updatedLines = Array.from(this.editor.querySelectorAll('.editor-line'));
                            lines.length = 0;
                            lines.push(...updatedLines);
                            
                            // Don't increment i, check the same position again
                            continue;
                        }
                    }
                    
                    i++;
                }
                
                // Update line indices
                this.editingController.updateLineIndices();
            }
        }

        // Initialize settings, minimap, and mode manager
        let settingsManager, minimapManager, modeManager;
        
        try {
            settingsManager = new SettingsManager();
            
            // Wait for editingController to be initialized
            setTimeout(() => {
                minimapManager = new MinimapManager(editor, editingController);
                modeManager = new ModeManager(editor, editingController);
                
                // Make globally accessible
                window.minimapManager = minimapManager;
                window.modeManager = modeManager;
                
                // Initial minimap update with retries
                setTimeout(() => {
                    if (minimapManager) minimapManager.update();
                }, 500);
                setTimeout(() => {
                    if (minimapManager) minimapManager.update();
                }, 1500);
                setTimeout(() => {
                    if (minimapManager) minimapManager.update();
                }, 3000);
                
                // Add periodic line number and minimap updates (after initialization)
                setInterval(() => {
                    if (editingController && editingController.updateLineNumbersNow) {
                        editingController.updateLineNumbersNow();
                    }
                    if (minimapManager) {
                        minimapManager.update();
                    }
                }, 3000);
            }, 200);
        } catch (error) {
            console.error('Failed to initialize settings/minimap:', error);
        }

        // Initial render with error handling
        // Use requestAnimationFrame to ensure CSS computed values are available
        requestAnimationFrame(() => {
            try {
                updateAll();

                // Editor initialization is handled by AutosaveManager
            } catch (error) {
                // Fallback to basic functionality
                editor.focus();
            }
        });

        // Use MutationObserver to detect style changes on body (for theme changes, etc.)
        const mo = new MutationObserver(() => debouncedUpdateAll(80));
        mo.observe(document.documentElement, { attributes: true, attributeFilter: ["class", "style"] });

        // Add keyboard shortcuts for formatting
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key.toLowerCase()) {
                    case 'b':
                        e.preventDefault();
                        toolbarController.toggleFormatting('bold');
                        break;
                    case 'i':
                        e.preventDefault();
                        toolbarController.toggleFormatting('italic');
                        break;
                    case 'c':
                        // Ctrl+Shift+C = Copy All
                        if (e.shiftKey && copyAllBtn) {
                            e.preventDefault();
                            copyAllBtn.click();
                        }
                        // Regular Ctrl+C is handled by browser
                        break;
                    case 's':
                        e.preventDefault();
                        // Save functionality
                        saveBtn.click();
                        break;
                    case 'z':
                        e.preventDefault();
                        if (e.shiftKey) {
                            // Ctrl+Shift+Z = Redo
                            editingController.redo();
                        } else {
                            // Ctrl+Z = Undo
                            editingController.undo();
                        }
                        break;
                    case 'y':
                        e.preventDefault();
                        // Ctrl+Y = Redo (alternative)
                        editingController.redo();
                        break;
                    case 'r':
                        // Only if Ctrl+Shift+R (for debugging)
                        if (e.shiftKey) {
                            e.preventDefault();
                            window.forceEditorReinitialize();
                        }
                        break;
                }
            }
        });

    })();
</script>
</body>

</html>